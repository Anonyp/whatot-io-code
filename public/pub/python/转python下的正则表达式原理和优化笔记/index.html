<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>转:Python下的正则表达式原理和优化笔记 | Whatot 日常积累</title>
  <meta name="author" content="whatot">
  
  <meta name="description" content="whatot blog">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="转:Python下的正则表达式原理和优化笔记"/>
  <meta property="og:site_name" content="Whatot 日常积累"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Whatot 日常积累" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Whatot 日常积累</a></h1>
  <h2><a href="/">积累每一天，无论是技术还是生活</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">主页</a></li>
    
      <li><a href="/archives">存档</a></li>
    
      <li><a href="/links">链接</a></li>
    
      <li><a href="/tools">工具集</a></li>
    
      <li><a href="/about">关于</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2013-06-19T01:16:40.000Z"><a href="/pub/python/转python下的正则表达式原理和优化笔记/">6月 19 2013</a></time>
      
      
  
    <h1 class="title">转:Python下的正则表达式原理和优化笔记</h1>
  

    </header>
    <div class="entry">
      
        <p>本文转载：<a href="http://my.oschina.net/o0Kira0o/blog/138516" target="_blank">原文地址</a></p>
<p>摘要： 本文旨在总结一些编写表达式的技巧和原理。鉴于介绍python中re模块的使用方法的文章太多。所以本文在基础方面都是略过，而在回溯原理和一些技巧方面记录一点点学习总结。<br><a id="more"></a></p>
<p>目录：</p>
<pre><code>基础规则的介绍
    <span class="keyword">python</span>中的转义符号干扰
    基本字符
    量词限定符
    锚点符
    正则引擎内部的转义符号
    字符集
    括号的相关内容
        普通型括号
        扩展型括号
        匹配优先/忽略优先符号
相关进阶知识
    传统型NFA中的顺序问题
    回溯/备用状态
        备用状态
        回溯机制两个要点
    固化分组思想
        Python模拟固化过程
    多选结构
一些优化的理念和技巧
    平衡法则
    处理不期望的匹配
    对数据的了解和假设
    引擎中一般存在的优化项
其他技巧和补充内容
    过度回溯问题
        消除指数级匹配
    效率测试代码
    量词等价转换
    锚点优化的利用
    排除型数组的利用
    常识优化措施
    避免无休止匹配的核心公式</code></pre>
<p>最近的时间内对正则表达式进行了一点点学习。所选教材是《mastering regular expressions》，也就是所谓的《精通正则表达式》。读过一遍后，顿感正则表达式的强大和精湛之处。其中前三章是对正则表达式的基本规则的介绍和铺垫。七章以后是对在具体语言下的应用。而核心的部分则是四五六这三章节。</p>
<p>其中第四章是讲了整个正则表达式的精华，即传统引擎NFA的回溯思想。第五章是一些例子下对回溯思想的理解。第六章则是对效率上的研究。根源也是在回溯思想上的引申和研究。</p>
<p>这篇文章是我结合python官方re模块的文档以及这本书做一个相应的总结。</p>
<p>其中官方的文档： (<a href="http://docs.python.org/3.3/library/re.html" target="_blank">http://docs.python.org/3.3/library/re.html</a>)</p>
<p>由于我都是在python上联系和使用的，所以后面的问题基本都是在python上提出来的，所以这本书中的其它正则流派我均不涉及。依书中，python和perl风格差不多，属于传统NFA引擎，也就是以“表达式主导“，采用回溯机制，匹配到即停止（ 顺序敏感，不同于POSIX NFA等采用匹配最左最长的结果）。</p>
<p>对于回溯部分，以及谈及匹配的时候，将引擎的位置总是放在字符和字符之间，而不是字符本身。比如^对应的是第一个字符之前的那个”空白“位置。</p>
<h2>基础规则的介绍</h2>
<h3>python中的转义符号干扰</h3>
<p>python中，命令行和脚本等，里面都会对转义符号做处理，此时的字符串会和正则表达式的引擎产生冲突。即在python中字符串&#39;\n&#39;会被认为是换行符号，这样的话传入到re模块中时便不再是‘\n’这字面上的两个符号，而是一个换行符。所以，我们在传入到正则引擎时，必须让引擎单纯的认为是一个&#39;\‘和一个’n‘，所以需要分别加上转义符，成为’\\n&#39;，针对这个情况，python中使用raw_input方式，在字符串前加上r，使字符串中的转义符不再特殊处理（即python中不处理，统统丢给正则引擎来处理），那么换行符就是r&#39;\n&#39;</p>
<h3>基本字符</h3>
<pre><code>.        <span class="comment">#普通模式下，匹配除换行符外的任意字符。（指定DOTALL标记以匹配所有字符）</span></code></pre>
<h3>量词限定符</h3>
<pre><code>*        <span class="comment">#匹配前面的对象0个或多个。千万不要忽略这里的0的情况。</span>
+        <span class="comment">#匹配前面的对象1个或多个。这里面的重点是至少有一个。</span>
?        <span class="comment">#匹配前面的对象0个或1个。</span>
{m}      <span class="comment">#匹配前面的对象m次</span>
{m,n}    <span class="comment">#匹配前面的对象最少m次，最多n次。</span></code></pre>
<h3>锚点符</h3>
<pre><code>^        <span class="comment">#匹配字符串开头位置，MULTILINE标记下，可以匹配任何\n之后的位置</span>
<span class="variable">$ </span>       <span class="comment">#匹配字符串结束位置，MULTILINE标记下，可以匹配任何\n之前的位置</span></code></pre>
<h3>正则引擎内部的转义符号</h3>
<pre><code><span class="command">\m</span>    m是数字，所谓的反向引用，即引用前面捕获型括号内的匹配的对象。数字是对应的括号顺序。
<span class="command">\A</span>    只匹配字符串开头
<span class="command">\b</span>    可以理解一个锚点的符号，此符号匹配的是单词的边界（"单词边界符"）。这其中的word定义为连续的字母，数字和下划线。
      准确的来说，<span class="command">\b</span>的位置是在<span class="command">\w</span>和<span class="command">\W</span>的交界处，当然还有字符串开始结束和<span class="command">\w</span>之间。
<span class="command">\B</span>    和<span class="command">\b</span>对应，本身匹配空字符，但是其位置是在非"边界"情况下，比如r'py<span class="command">\B</span>'可以匹配python，但不能匹配'py,','py.' 等等
<span class="command">\d</span>    匹配数字
<span class="command">\D</span>    匹配非数字
<span class="command">\s</span>    未指定UNICODE和LOCALE标记时，等同于<span class="special">[</span> <span class="command">\t</span><span class="command">\n</span><span class="command">\r</span><span class="command">\f</span><span class="command">\v</span><span class="special">]</span>，注意<span class="command">\t</span>之前是一个空格，表示也匹配空格。
<span class="command">\S</span>    与<span class="command">\s</span>相反
<span class="command">\w</span>    未指定UNICODE和LOCALE标记时，等同于<span class="special">[</span>a-zA-Z0-9_<span class="special">]</span>
<span class="command">\W</span>    和<span class="command">\w</span>相反
<span class="command">\Z</span>    只匹配字符串的结尾</code></pre>
<p>其他的一些python支持的转移符号也都有支持，如前面的&#39;\t&#39;</p>
<h3>字符集</h3>
<pre><code>[]</code></pre>
<p>尤其注意，这个字符集最终 <strong>只匹配一个字符（既不是空，也不是一个以上）</strong>！所以，前面的一些量词限定符，在这里失去了原有的意义。</p>
<p>另外，‘-’符号放在两个字符之间的时候，表示ASCII字符之间的所有字符，如[0-9]，表示0到9.<br>而当放在字符集开头或者结尾，或者被&#39;\‘转义时候，则只是表示特指’-&#39;这个符号<br>最后，当在开头的地方使用‘^’,表示排除型字符组.</p>
<h3>括号的相关内容</h3>
<h4>普通型括号</h4>
<pre><code>(<span class="keyword">...</span>)    普通捕获型括号，可以被\number引用。</code></pre>
<h4>扩展型括号</h4>
<pre><code>(?aiLmsx)
a        re.A
i        re.I    <span class="comment">#忽略大小写</span>
L        re.L
m        re.M
s        re.S    <span class="comment">#点号匹配包括换行符</span>
x        re.X    <span class="comment">#可以多行写表达式</span>

(?:......)      <span class="comment">#非捕获型括号，此括号不记录捕获内容，可节省空间   </span>
(?P&lt;name&gt;<span class="keyword">...</span>)   <span class="comment">#此捕获型括号可以使用name来调用，而不必依赖数字。调用时使用(?P=name)</span>
(?<span class="comment">#...)         #注释型括号，此括号完全被忽略</span>
(?=<span class="keyword">...</span>)         <span class="comment">#lookahead assertion 如果后面是括号中的，则匹配成功</span>
(?!<span class="keyword">...</span>)         <span class="comment">#negative lookahead assertion    如果后面不是括号中的，则匹配成功</span>
(?&lt;=<span class="keyword">...</span>)        <span class="comment">#positive lookbehind assertion    如果前面是括号中的，则匹配成功</span>
(?&lt;!<span class="keyword">...</span>)        <span class="comment">#negative lookbehind assertion    如果前面不是括号中的，则匹配成功</span>
        <span class="comment">#以上&lt;span&gt;&lt;b&gt;四种类型断言&lt;/b&gt;&lt;/span&gt;，本身均不匹配内容，</span>
        <span class="comment">#  只是告知正则引擎是否开始匹配或者停止。</span>
        <span class="comment">#另外在后两种后项断言中，必须为&lt;b&gt;定长断言&lt;/b&gt;。</span>
(?(id/name)yes-pattern|no-pattern)
        <span class="comment">#如有由id或者name指定的组存在的话，将会匹配yes-pattern，</span>
        <span class="comment">#  否则将会匹配no-pattern，通常情况下no-pattern也可以省略。</span></code></pre>
<h4>匹配优先/忽略优先符号</h4>
<p>在量词限定符中，默认的情况都是匹配优先，也就是说，在符合条件的情况下，正则引擎会尽量匹配多的字符（<strong>贪婪规则</strong>）</p>
<p>在这些符号后面加上‘?’，则正则引擎会成为忽略优先，此时的正则引擎会优先匹配 尽可能少的情况。</p>
<p>如‘??’会优先匹配没有的情况，然后才是1个对象的情况。而{m,n}?则是优先匹配m个对象，而不是占多的n个对象。</p>
<h2>相关进阶知识</h2>
<p>首先放在最前面，python属于perl风格，属于传统型NFA引擎，与此相对的是POSIX NFA和DFA。所以大部分讨论都针对传统型NFA</p>
<h3>传统型NFA中的顺序问题</h3>
<p>NFA是基于<strong>正则表达式主导</strong>的引擎，同时，传统型NFA引擎会在找到符合状态的情况下立即停止。即得到匹配之后就停止引擎。相对来说，POSIX NFA 中不会立刻停止，其会在所有可能匹配的结果中寻求最长结果。这也是有些bug在传统型NFA中不会出现，但是放到后者中，会出现无法结束的情况。</p>
<p>引申一点，<strong>NFA学名为”非确定型有穷自动机“，DFA学名为”确定型有穷自动机“</strong><br>这里的非确定和确定均是指被匹配的目标文本中的字符来说的，在NFA中，每个字符在一次匹配中即使被检测通过，也不能确定他是否真正通过，因为NFA中会出现回溯！甚至不止一两次。图例见后面例子。而在DFA中，由于是<strong>目标文本主导</strong>，所有对象字符只检测一遍，到文本结束后，过就是过，不过就不过。这也就是”确定“这个词的来历。</p>
<h3>回溯/备用状态</h3>
<h4>备用状态</h4>
<p>当出现可选分支时，会将其他的选项存储起来，作为备用状态。当前的匹配失败时，引擎进行回溯，则会回到最近的备用状态。</p>
<p>匹配的情况中，匹配优先与忽略优先某种意义上是一致的，只是顺序上有所区别。当存在多个匹配时，两种方式进行的情况很可能是不同的，但是当不存在匹配时，他们俩的情况是一致的，即必然尝试了所有的可能。</p>
<h4>回溯机制两个要点</h4>
<pre><code>1，在是进行尝试还是跳过尝试时，匹配优先量词和忽略优先量词会作出相应决定。
2，匹配失败时，回溯需要返回到上一个备用状态，原则是后进先出（LIFO）</code></pre>
<h4>回溯典型举例：</h4>
<p><img src="/img/python-re-01.png" alt=""></p>
<p>这里可以看到，传统型NFA到D点即匹配结束。而在POSIX NFA中，需要找到所有结果，并在这些结果中取最长的结果返回。</p>
<p>当无法出现匹配时，如下图，我们看到POSIX NFA和传统型NFA的匹配路径是一致的。</p>
<p><img src="/img/python-re-02.png" alt=""></p>
<p>以上的例子引发了一个匹配时的思考，我们尽量避免使用&#39;.<em>&#39;<br>，因为其总是可以匹配到最末或者行尾，既然我们只寻求引号之间的数据，往往可以借助<strong>排除型数组</strong>来完成工作。<br>此例中，使用``&#39;[^‘’]</em>&#39;``这个的作用显而易见，我们只匹配非引号的内容，那么遇到第一个引号即可退出*号控制权。</p>
<h3>固化分组思想</h3>
<p>固化分组的思想很重要， 但是python中并不支持。即在使用<code>(?&gt;...)</code>括号中的匹配时产生的备选状态一旦离开括号，便会被引擎抛弃掉。举个典型的例子如：</p>
<pre><code>'<span class="command">\w</span>+:'</code></pre>
<p>这个匹配的情况是这样的，会优先去匹配所有的符合\w的字符，然后假如字符串的末尾没有:，即匹配未找到冒号，此时触发回溯机制，他会迫使前面的\w+释放字符，并且在交还的字符中重新尝试与‘:’作比对。但是问题出现在\w是不包含冒号的，显然无论如何都不会匹配成功，但是依照回溯机制，就会造成无谓的比对，这是对资源的浪费。所以我们就需要避免这种回溯，对此的方法就是将前面匹配到的内容固化，不令其存储备用状态，那么引擎就会因为没有备用状态可用而结束匹配过程。大大减少回溯的次数。</p>
<h4>Python模拟固化过程</h4>
<p>虽然python中不支持，但书中提供了利用前向断言来模拟固化过程。</p>
<pre><code>(?=(<span class="keyword">...</span>))\<span class="number">1</span></code></pre>
<p>这里注意的是断言中的结果是不会保存备用状态的，虽然他本身不匹配内容，但是可以巧妙的添加一个捕获型括号来利用反向引用来达到此效果。对应上面的例子则是：</p>
<pre><code>'(?=(<span class="command">\w</span>+))\1:'</code></pre>
<h3>多选结构</h3>
<p>多选结构在传统型NFA中， 既不是匹配优先也不是忽略优先。而是按照顺序进行的。这样就更可以很好的利用此特点进行调试。</p>
<blockquote>
<p>1，在相对的应用中，在结果保证正确的情况下，应该优先的去匹配更可能出现的结果。即将可能性大的分支尽可能放在靠前。<br>2，多选结构的代价。不能滥用多选结构，因为当匹配到多选结构时，缓存会记录下相应数目的备用状态。举例子如：[abcdef]和‘a|b|c|d|e|f’这两个表达式很可能经过稍稍修改都能完成你的某个任务，<br>但是尽量选择字符型数组，显然后者会在每次比较时建立6个备用状态，会占用一定的内存。</p>
</blockquote>
<h2>一些优化的理念和技巧</h2>
<h3>平衡法则</h3>
<p>好的正则表达式需寻求如下平衡：</p>
<ol>
<li>只匹配期望的文本，排除不期望的文本。(善于使用非捕获型括号)</li>
<li>必须易于控制和理解</li>
<li>使用NFA引擎，必须保证效率（如果能够匹配，必须很快地返回匹配结果，如果不能匹配，应该在尽可能短的时间内报告匹配失败。）</li>
</ol>
<h3>处理不期望的匹配</h3>
<p>在处理过程中，我们总是习惯于使用星号等非硬性规定的量词，可能我们使用的匹配表达式中没有必须匹配的字符，如量词均为‘?’,&#39;*&#39;等，那么其结果必然会出现不可控，这是我们必须需要处理的。</p>
<h3>对数据的了解和假设</h3>
<p>其实在处理很多数据的时候，我们的操作数据情况都是不一样的，有时会很规整，那么我们可以省掉考虑复杂表达式的情况，但是反过来，就需要思考多一些，对各种可能的情形做相应的处理。</p>
<h3>引擎中一般存在的优化项</h3>
<h4>编译缓存</h4>
<p>反复使用编译对象时，应该在使用前，使用re.compile()方法来进行编译，这样在后面调用时不必每次重新编译。节省时间。尤其是在循环体中反复调用正则匹配时。</p>
<h4>锚点优化</h4>
<p>配合一些引擎的优化，应尽量将锚点单独凸显出来。对比^a|^b，其效率便不如^(a|b)<br>同样的道理，系统也会处理行尾锚点优化。所以在写相关正则时，如果有可能的话，将锚点使用出来。</p>
<h4>量词优化</h4>
<p>引擎中的优化，会对如.<em> 这样的量词进行统一对待，而不是按照传统的回溯规则，所以，从理论上说&#39;(?:.)</em>‘ 和’.<em>‘是等价的，不过具体到引擎实现的时候，则会对’.</em>&#39;进行优化。速度就产生了差异。</p>
<h4>消除不必要括号以及字符组</h4>
<p>这个在python中是否有 未知。只是在支持的引擎中，会对如[.]中转化成.，因为显然后者的效率更高（字符组处理引起额外开销）</p>
<p>以上是一些引擎带的优化，自然实际上是我们无法控制的的，不过了解一些后，对我们后面的一些处理和使用有很大帮助。</p>
<h2>其他技巧和补充内容</h2>
<h3>过度回溯问题</h3>
<h4>消除指数级匹配</h4>
<p>形如下面：</p>
<pre><code>（<span class="command">\w</span>+)*</code></pre>
<p>这种情况的表达式，在匹配长文本的时候，会遇到什么问题呢，如果在文本匹配失败时（意味着如果失败，则说明已经回溯了<br><strong>所有的可能</strong>），想象一下，<em>号退一个状态，里面的+号就包括其余的<strong>所有状态</strong>，验证后，回到外面，</em>号退到倒数第二个备用状态，再回去，+号又要回溯一边比上一轮差1的<strong>备用状态</strong>数，当字符串很长时，就会出现<strong>指数级的回溯总数</strong>。系统就会‘卡死’。甚至当有匹配时，这个匹配藏在回溯总数的中间时，也是会造成卡死的情况。所以，使用NFA的引擎时，必须要注意这个问题。</p>
<p><strong>我们采用如下思路去避免这个问题</strong>：</p>
<p>占有优先量词（python中使用前向断言加反向引用模拟）<br>道理很简单，既然庞大的回溯数量都是被储存的备用状态导致的，那么我们直接使引擎放弃这些状态</p>
<pre><code><span class="keyword">import</span> re
re_lx = re.compile(<span class="string">r'(?=(\w+))\1*\d'</span>)</code></pre>
<h3>效率测试代码</h3>
<p>在测试表达式的效率时，可借助以下代码比较所需时间。</p>
<pre><code><span class="keyword">import</span> re
<span class="keyword">import</span> time
re_lx1 = re.compile(<span class="string">r'your_re_1'</span>)
re_lx2 = re.compile(<span class="string">r'your_re_2'</span>)
starttime = time.time()
repeat_time = <span class="number">100</span>
<span class="keyword">for</span> i <span class="keyword">in</span> range(repeat_time):
    s=<span class="string">'test text'</span>*<span class="number">10000</span>
    result = re_lx1.search(s)
time1 = time.time()-starttime
print(time1)
starttime = time.time()
<span class="keyword">for</span> i <span class="keyword">in</span> range(repeat_time):
    s=<span class="string">'test text'</span>*<span class="number">10000</span>
    result = re_lx2.search(s)
time2 = time.time()-starttime
print(time2)</code></pre>
<h3>量词等价转换</h3>
<p>现在来看看大括号量词的效率问题</p>
<ol>
<li><p>当大括号修饰的对象是类似于字符数组或者\d这种非确定性字符时，使用大括号效率高于重复叠加对象。即：</p>
<pre><code> <span class="command">\d</span><span class="special">{</span>5<span class="special">}</span>  优于  <span class="command">\d</span><span class="command">\d</span><span class="command">\d</span><span class="command">\d</span><span class="command">\d</span></code></pre>
</li>
</ol>
<p>经测试在python中后者优于前者。会快很多.</p>
<ol>
<li><p>但是当重复的字符时确定的某一个字符时，则简单的重复叠加对象的效率会高一些。这是因为引擎会对单纯的字符串内部优化（虽然我们不知道具体优化是如何做到的）</p>
<pre><code> <span class="tag">aaaaa</span>  优于  <span class="tag">a</span><span class="rules">{<span class="rule">5}</span></span></code></pre>
</li>
</ol>
<p>总体上说&#39;\d‘ 肯定是慢于’1&#39;</p>
<p>我使用的python3中的re模块，经测试，不使用量词会快。</p>
<h3>锚点优化的利用</h3>
<p>下面这个例子，在我们可以估计到的文本中，假设出现匹配的内容在字符串对象的结尾，那么我们利用如下第一个表达式是快于第二个表达式的，原因在于前者有锚点的优势。</p>
<pre><code>re_lx1 = re.compile(<span class="string">r'\d{5}$'</span>)   
re_lx2 = re.compile(<span class="string">r'\d{5}'</span>)</code></pre>
<h3>排除型数组的利用</h3>
<p>继续上面的例子，我们发现\w是包含\d的，当使用匹配优先时，前面的\w会掠过数字，之所以能匹配成功，或者确定失败，是后面的\d迫使前面的量词交还一些字符。<br>知道这一点，我们应该尽量避免回溯，一个顺其自然的想法就是不让前面的匹配优先量词涉及到\d</p>
<pre><code>re_lx1 = re.compile(<span class="string">r'^\w+(\d{5})'</span>)
re_lx2 = re.compile(<span class="string">r'^[^\d]+\d{5}'</span>)    <span class="comment">#优于上面的表达式</span></code></pre>
<p>在我们没有时间去深入研究模块代码的时候，只能通过尝试和反复修改来得到最终的复合预期的表达式。</p>
<h3>常识优化措施</h3>
<p>然而我们利用可能的提升效果去尝试修改的时候很有可能 适得其反 ， 因为某些我们看来缓慢的回溯在正则引擎内部会进行一定的优化 ，“取巧”的修改又可能会关闭或者避开了这些优化，所以结果也许会令我们很失望。</p>
<p>以下是书中提到的一些 常识性优化措施：</p>
<blockquote>
<ol>
<li>避免重新编译（循环外创建对象）</li>
<li>使用非捕获型括号（节省捕获时间和回溯时状态的数量）</li>
<li>善用锚点符号</li>
<li>不滥用字符组</li>
<li>提取文本和锚点。将他们从可能的多选分支结构中提取出来，会提取速度。</li>
<li>最可能的匹配表达式放在多选分支前面</li>
</ol>
</blockquote>
<h3>避免无休止匹配的核心公式</h3>
<p>opening normal<em>(special normal</em>)* closing</p>
<p>这个公式 特别用来对于匹配在两个特殊符号内的文本</p>
<p>有如下的三点避免无休止匹配的发生。</p>
<blockquote>
<ol>
<li>special部分和normal部分匹配的开头不能重合。一定保证这两部分在任何情况下不能匹配相同的内容，不然在无法出现匹配时遍历所有情况，此时引擎的路径就不能确定。</li>
<li>normal部分必须匹配至少一个字符</li>
<li>special部分必须是固定长度的</li>
</ol>
</blockquote>

      
    </div>
    <footer>
      
        
  
  <div class="categories">
    <a href="/categories/python/">python</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/python/">python</a>, <a href="/tags/regex/">regex</a>
  </div>

        
  <div class="addthis addthis_toolbox addthis_default_style">
    
      <a class="addthis_button_facebook_like" fb:like:layout="button_count"></a>
    
    
      <a class="addthis_button_tweet"></a>
    
    
      <a class="addthis_button_google_plusone" g:plusone:size="medium"></a>
    
    
      <a class="addthis_button_pinterest_pinit" pi:pinit:layout="horizontal"></a>
    
    <a class="addthis_counter addthis_pill_style"></a>
  </div>
  <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js"></script>

      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>

</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:whatot.github.io">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/algorithm/">algorithm</a><small>1</small></li>
  
    <li><a href="/categories/basis/">basis</a><small>1</small></li>
  
    <li><a href="/categories/c/">c</a><small>3</small></li>
  
    <li><a href="/categories/database/">database</a><small>6</small></li>
  
    <li><a href="/categories/fun/">fun</a><small>1</small></li>
  
    <li><a href="/categories/git/">git</a><small>1</small></li>
  
    <li><a href="/categories/kernel/">kernel</a><small>2</small></li>
  
    <li><a href="/categories/linux/">linux</a><small>6</small></li>
  
    <li><a href="/categories/linux_program/">linux_program</a><small>2</small></li>
  
    <li><a href="/categories/program/">program</a><small>1</small></li>
  
    <li><a href="/categories/python/">python</a><small>1</small></li>
  
    <li><a href="/categories/thought/">thought</a><small>2</small></li>
  
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/CPU/">CPU</a><small>1</small></li>
  
    <li><a href="/tags/algorithm/">algorithm</a><small>1</small></li>
  
    <li><a href="/tags/bash/">bash</a><small>1</small></li>
  
    <li><a href="/tags/c/">c</a><small>3</small></li>
  
    <li><a href="/tags/cache/">cache</a><small>1</small></li>
  
    <li><a href="/tags/career/">career</a><small>1</small></li>
  
    <li><a href="/tags/database/">database</a><small>6</small></li>
  
    <li><a href="/tags/fun/">fun</a><small>1</small></li>
  
    <li><a href="/tags/git/">git</a><small>1</small></li>
  
    <li><a href="/tags/kernel/">kernel</a><small>3</small></li>
  
    <li><a href="/tags/language/">language</a><small>4</small></li>
  
    <li><a href="/tags/linux/">linux</a><small>7</small></li>
  
    <li><a href="/tags/math/">math</a><small>1</small></li>
  
    <li><a href="/tags/perf/">perf</a><small>1</small></li>
  
    <li><a href="/tags/program/">program</a><small>6</small></li>
  
    <li><a href="/tags/python/">python</a><small>1</small></li>
  
    <li><a href="/tags/regex/">regex</a><small>1</small></li>
  
    <li><a href="/tags/shell/">shell</a><small>6</small></li>
  
    <li><a href="/tags/thought/">thought</a><small>2</small></li>
  
    <li><a href="/tags/vim/">vim</a><small>1</small></li>
  
  </ul>
</div>


  
<div class="widget tagcloud">
  <h3 class="title">标签云</h3>
  <div class="entry">
    <a href="/tags/CPU/" style="font-size: 10.00px;">CPU</a><a href="/tags/algorithm/" style="font-size: 10.50px;">algorithm</a><a href="/tags/bash/" style="font-size: 11.00px;">bash</a><a href="/tags/c/" style="font-size: 11.50px;">c</a><a href="/tags/cache/" style="font-size: 12.00px;">cache</a><a href="/tags/career/" style="font-size: 12.50px;">career</a><a href="/tags/database/" style="font-size: 13.00px;">database</a><a href="/tags/fun/" style="font-size: 13.50px;">fun</a><a href="/tags/git/" style="font-size: 14.00px;">git</a><a href="/tags/kernel/" style="font-size: 14.50px;">kernel</a><a href="/tags/language/" style="font-size: 15.00px;">language</a><a href="/tags/linux/" style="font-size: 15.50px;">linux</a><a href="/tags/math/" style="font-size: 16.00px;">math</a><a href="/tags/perf/" style="font-size: 16.50px;">perf</a><a href="/tags/program/" style="font-size: 17.00px;">program</a><a href="/tags/python/" style="font-size: 17.50px;">python</a><a href="/tags/regex/" style="font-size: 18.00px;">regex</a><a href="/tags/shell/" style="font-size: 18.50px;">shell</a><a href="/tags/thought/" style="font-size: 19.00px;">thought</a><a href="/tags/vim/" style="font-size: 19.50px;">vim</a>
  </div>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2013 whatot
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>