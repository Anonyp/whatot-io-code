<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>转:高效操作Bash | Whatot 日常积累</title>
  <meta name="author" content="whatot">
  
  <meta name="description" content="whatot blog">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="转:高效操作Bash"/>
  <meta property="og:site_name" content="Whatot 日常积累"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Whatot 日常积累" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Whatot 日常积累</a></h1>
  <h2><a href="/">积累每一天，无论是技术还是生活</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">主页</a></li>
    
      <li><a href="/archives">存档</a></li>
    
      <li><a href="/links">链接</a></li>
    
      <li><a href="/tools">工具集</a></li>
    
      <li><a href="/about">关于</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2013-07-27T02:28:07.000Z"><a href="/pub/linux/linux/转:高效操作bash/">7月 27 2013</a></time>
      
      
  
    <h1 class="title">转:高效操作Bash</h1>
  

    </header>
    <div class="entry">
      
        <p>作者：ahei</p>
<p>原文地址：<a href="http://ahei.info/bash.htm" target="_blank"><a href="http://ahei.info/bash.htm">http://ahei.info/bash.htm</a></a></p>
<p>我们在平常工作中大量使用linux, 而使用linux的过程中操作Bash更是非常之频繁, 所以怎样高效的操作Bash是一个非常重要的问题. 下面我结合自己的经验总结一下高效操作Bash的一些技巧.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="number">1</span> 快捷键
	<span class="number">1.1</span> 注意
	<span class="number">1.2</span> 重度推荐
	<span class="number">1.3</span> 常用快捷键
	<span class="number">1.4</span> 高级快捷键
	<span class="number">1.5</span> 总结
<span class="number">2</span> 历史扩展
	<span class="number">2.1</span> 概念
	<span class="number">2.2</span> 事件指示器(Event Designators)
	<span class="number">2.3</span> 单词指示器(Word Designators)
	<span class="number">2.4</span> 修饰符(Modifiers)
	<span class="number">2.5</span> 例子
	<span class="number">2.6</span> 总结
<span class="number">3</span> shell技巧
	<span class="number">3.1</span> Here Documents
	<span class="number">3.2</span> Here Strings
	<span class="number">3.3</span> 进程替换(<span class="keyword">Process</span> Substitution)
</pre></td></tr></table></figure>

<a id="more"></a>



<h1>1 快捷键</h1>
<h2>1.1 注意</h2>
<p>本文的快捷键表示中, C 表示Ctrl键, M表示Alt健. 这些快捷键中, 有一个小规律,<br>    对字符操作一般是C开头, 对单词操作一般是M开头. 如果你用SecureCRT,<br>    默认的话, 会输入不了Alt开头的快捷键, 因为Alt被当作菜单快捷键了, 可以点<br>    选项 <code>-&gt;</code> 回话选项, 选择tab 终端 <code>-&gt;</code> 仿真 <code>-&gt;</code> Emacs,<br>    把”使用Alt键作为元键”打勾. 如果你用gnome-terminal,<br>    默认状态下也输入不了Alt开头的快捷键，也被当作菜单快捷键了，可以点 编辑<br>    <code>-&gt;</code> 键盘快捷键, 把＂启用菜单快捷键＂前面的勾去掉.</p>
<p>下面的快捷键中很多以Ctrl键开头, 很多键盘的Ctrl键并不是很好按, 可以尝试把Ctrl键和Capslock键交换.</p>
<h2>1.2 重度推荐</h2>
<p><strong>C-r</strong></p>
<p>有时候，如果你想重新输入以前输入过的某条命令怎么办? 我见过两种做法：</p>
<ol>
<li>不停的按向上方向键，试图找出那条命令</li>
<li>输入history命令，然后找到那条命令，或者grep一把history命令的输出</li>
</ol>
<p>其实, 你有更好的选择, 那就是按 C-r, 然后输入你想要的命令中含有的单词, 就会出现含有这个单词的命令, 如果它不是你想要的命令, 就继续按C-r, 知道出现你想要的命令为止. C-r效果:</p>
<pre><code>(<span class="keyword">reverse</span>-i-search)<span class="string">`ls': ls a b c</code></pre>
<p><strong>M-.</strong></p>
<p>我经常见别人用<code>mkdir long-long-long-name-dir</code>后, 再输入<code>cd</code>,<br>    后面跟那个长的不能再长的目录名, 这时候我就会告诉他,<br>    其实你输入完<code>cd</code>后, 可以按<code>M-.</code>,<br>    就可以自动输入那个长的不能再长的目录名了. 其实,<br>    <code>M-</code>.的真正作用就是把上一条命令的最后一个参数输入到当前命令行.<br>    非常非常之方便, 强烈推荐. 如果继续按<code>M-.</code>,<br>    会把上上条命令的最后一个参数拿过来. 同样,<br>    如果你想把上一条命令第一个参数拿过来咋办呢? 用<code>M-0 M-.</code>,<br>    就是先输入<code>M-0</code>, 再输入<code>M-.</code>. 如果是上上条命令的第一个参数呢?<br>    当然是<code>M-0 M-. M-.</code>了.</p>
<h2>1.3 常用快捷键</h2>
<p><strong>程序控制</strong></p>
<table><br>    <caption>程序控制</caption><br>    <thead><br>        <tr><br>            <th>意义</th><br>            <th>快捷键</th><br>        </tr><br>    </thead><br>    <tbody><br>        <tr><br>            <td>终止当前在前台运行的程序</td><br>            <td>C-c</td><br>        </tr><br>        <tr><br>            <td>挂起当前在前台运行的程序</td><br>            <td>C-z</td><br>        </tr><br>        <tr><br>            <td>如果光标在行首且当前行没有输入任何字符, C-d会退出当前会话</td><br>            <td>C-d</td><br>        </tr><br>    </tbody><br></table>


<p><strong>光标移动</strong></p>
<table><br>    <caption>光标移动</caption><br>    <thead><br>        <tr><br>            <th>意义</th><br>            <th>快捷键</th><br>        </tr><br>    </thead><br>    <tbody><br>        <tr><br>            <td>向前(Forward)移动一个字符</td><br>            <td>C-f</td><br>        </tr><br>        <tr><br>            <td>向后(Backward)移动一个字符</td><br>            <td>C-b</td><br>        </tr><br>        <tr><br>            <td>向前移动一个单词</td><br>            <td>M-f</td><br>        </tr><br>        <tr><br>            <td>向后移动一个单词</td><br>            <td>M-b</td><br>        </tr><br>        <tr><br>            <td>移动光标到行首</td><br>            <td>C-a</td><br>        </tr><br>        <tr><br>            <td>移动光标到行尾</td><br>            <td>C-e</td><br>        </tr><br>    </tbody><br></table>

<p><strong>编辑</strong></p>
<table><br>    <caption>编辑</caption><br>    <thead><br>        <tr><br>            <th>意义</th><br>            <th>快捷键</th><br>        </tr><br>    </thead><br>    <tbody><br>        <tr><br>            <td>向前删一个字符</td><br>            <td>C-d</td><br>        </tr><br>        <tr><br>            <td>向后删一个字符</td><br>            <td>C-h</td><br>        </tr><br>        <tr><br>            <td>向前删一个单词</td><br>            <td>M-d</td><br>        </tr><br>        <tr><br>            <td>向后删一个单词, 单词之间以符号分割</td><br>            <td>C-M-h</td><br>        </tr><br>        <tr><br>            <td>向后删一个单词, 单词之间以空格分割</td><br>            <td>C-w</td><br>        </tr><br>        <tr><br>            <td>清屏, 相当于命令clear, 有了这个快捷键, 就不用每次努力的敲clear了</td><br>            <td>C-l</td><br>        </tr><br>        <tr><br>            <td>删除当前光标到行尾的字符</td><br>            <td>C-k</td><br>        </tr><br>        <tr><br>            <td>删除当前光标到行首的字符</td><br>            <td>C-u</td><br>        </tr><br>        <tr><br>            <td>粘贴删除环里面的第一项</td><br>            <td>C-y</td><br>        </tr><br>        <tr><br>            <td>粘贴删除环里面的后面的项</td><br>            <td>M-y</td><br>        </tr><br>        <tr><br>            <td>undo</td><br>            <td>C-/</td><br>        </tr><br>        <tr><br>            <td>取出上一条命令的最后一个参数</td><br>            <td>M-.</td><br>        </tr><br>    </tbody><br></table>


<p>对于<code>C-M-h</code>和<code>C-w</code>的区别, 看下面这个例子:</p>
<p>如果当前光标前面的字符串为“abc def-ghi”, <code>C-M-h</code>会删掉ghi,<br>    但是<code>C-w</code>会删掉”def-ghi”, 也就是说,<br>    <code>C-M-h</code>向后删的时候碰到非字母和数字就会停止, 但是<code>C-w</code>碰到空格才会停止.</p>
<p>Bash下有一个删除环(<code>kill-ring</code>),<br>    所有被删除的东西(用C-d删除的字符不算)都会进入这个环,<br>    <code>C-y</code>会粘贴环里面最近进去的项, 想要粘贴后面的项, 必须在按<code>C-y</code>后,<br>    不停的按<code>M-y</code>, 直到出来你想要的项为止.</p>
<p>有时候, 你想搜索某个文件中是否有TAB键, 你这时候会怎么做呢? 你或许会用grep, 在你输入完grep后, 你再按TAB, 这时候会出来什么? 什么都没出现! 再按? 出来:</p>
<p>Display all N possibilities? (y or n)</p>
<p>这是为何呢? 因为TAB是补全键. 那么是否是输入不了TAB吗? 不是! 按<code>C-v</code>后, 再按TAB即可. 同样, 想输入C-a, C-b也是同样的道理.</p>
<p><strong>历史命令操作</strong></p>
<table><br>    <caption>历史命令操作</caption><br>    <thead><br>        <tr><br>            <th>意义</th><br>            <th>快捷键</th><br>        </tr><br>    </thead><br>    <tbody><br>        <tr><br>            <td>从历史命令列表中取下一条命令, 相当于向下方向键</td><br>            <td>C-n</td><br>        </tr><br>        <tr><br>            <td>从历史命令列表中取上一条命令, 相当于向上方向键</td><br>            <td>C-p</td><br>        </tr><br>        <tr><br>            <td>向后增量搜索历史命令, 非常方便, 严重推荐, 有了它, 以前输入过的很长的命令, 可以不用重复输入</td><br>            <td>C-r</td><br>        </tr><br>        <tr><br>            <td>循环执行历史命令</td><br>            <td>C-o</td><br>        </tr><br>    </tbody><br></table>


<p>用<code>C-p</code>取出历史命令列表中某一个命令后,<br>    按<code>C-o</code>可以在这条命令到历史命令列表后面的命令之间循环执行命令,<br>    比如历史命令列表中有50条命令, 后面三项分别是命令A, 命令B, 命令C,<br>    用<code>C-p</code>取出命令A后, 再按<code>C-o</code>就可以不停的在命令A, 命令B,<br>    命令C中循环执行这三个命令. <code>C-o</code>有一个非常好用的地方,<br>    比如用cp命令在拷贝一个大目录的时候, 你肯定很想知道当前的拷贝进度,<br>    那么你现在该怎样做呢? 估计很多人会想到不停的输入<code>du -sh dir</code>去执行,<br>    但用<code>C-o</code>可以非常完美的解决这个问题, 方法就是:</p>
<ul>
<li>输入<code>du -sh dir</code>, 按回车执行命令</li>
<li><code>C-p, C-o</code>, 然后就可以不停的按<code>C-o</code>了, 会不停的执行<code>du -sh dir</code>这条命令</li>
</ul>
<p>其实上面这个问题也可以用watch命令解决:</p>
<p><code>watch -n 1 -d du -sh dir</code></p>
<h2>1.4 高级快捷键</h2>
<table><br>    <caption>高级快捷键</caption><br>    <thead><br>        <tr><br>            <th>意义</th><br>            <th>快捷键</th><br>        </tr><br>    </thead><br>    <tbody><br>        <tr><br>            <td>从当前光标处向前搜索字符</td><br>            <td>C-]</td><br>        </tr><br>        <tr><br>            <td>从当前光标处向后搜索字符</td><br>            <td>C-M-]</td><br>        </tr><br>        <tr><br>            <td>交换当前光标下的字符和光标前面的一个字符, 交换后, 光标向后移东一个字符</td><br>            <td>C-t</td><br>        </tr><br>        <tr><br>            <td>交换当前光标所在单词和光标前面一个单词, 交换后, 光标向后移动一个单词</td><br>            <td>M-t</td><br>        </tr><br>        <tr><br>            <td>把单词首字符变成大写, 其他变成小写</td><br>            <td>M-c</td><br>        </tr><br>        <tr><br>            <td>把单词变成小写</td><br>            <td>M-l</td><br>        </tr><br>        <tr><br>            <td>把单词变成大写</td><br>            <td>M-u</td><br>        </tr><br>        <tr><br>            <td>删除当前光标前面所有的空白字符</td><br>            <td>M-\</td><br>        </tr><br>        <tr><br>            <td>向后非增量搜索历史命令</td><br>            <td>M-p</td><br>        </tr><br>        <tr><br>            <td>相当于TAB健</td><br>            <td>C-i</td><br>        </tr><br>        <tr><br>            <td>相当于回车键</td><br>            <td>C-m/C-j</td><br>        </tr><br>        <tr><br>            <td>在当前光标处和上一次光标处不停的移动</td><br>            <td>C-x C-x</td><br>        </tr><br>    </tbody><br></table>

<h2>1.5 总结</h2>
<p>其实, 上面所说的快捷键并不是由Bash来控制的, 而是有一个叫readline的库来控制的, readline库用在很多地方, 比如gdb, mysql, 你使用gdb的时候, 是不是很奇怪, 为啥它也能用上下方向键取出前面后面的命令? 因为它用的也是readline库. 所以只要掌握了readline, 就掌握了Bash, gdb, mysql等程序里面的快捷键操作技巧. readline是一个非常非常强悍的库, 它有两种模式, 一个是Emacs模式, 另外一个是vi模式, Emacs模式非常适合在命令行下使用, 我上面说的快捷键都是针对Emacs模式来说的. readline的Emacs模式下的光标移动, 编辑等快捷键和Emacs下的快捷键也非常相近. 所以你学会了这些快捷键, 也快入门Emacs了, :) . readline也可以自定义快捷键, 它还有一套配置语法. 关于它的详细介绍, 可以man readline或者info readline, 也可以看看大牛王垠写的readline介绍.</p>
<h1>2 历史扩展</h1>
<h2>2.1 概念</h2>
<p>首先举个例子:<br>首先输入一条命令:</p>
<pre><code>ls abc <span class="function"><span class="keyword">def</span> <span class="title">ghi</span></code></pre>
<p>再输入:</p>
<pre><code>!!*<span class="symbol">:s/b/d</span></code></pre>
<p>那么实际上执行的命令是:</p>
<pre><code>adc <span class="function"><span class="keyword">def</span> <span class="title">ghi</span></code></pre>
<p>我来解释一下, <code>!!</code>表示从命令历史列表中取上一条历史命令”ls abc def ghi”,<br>    <code>*</code>表示选择取刚才选择的命令的所有参数, 即: “abc def ghi”,<br>    <code>:s/b/d</code>表示对刚才取出来的参数”abc def ghi”进行替换, 把第一个出现的b替换成d</p>
<p>从上面可以看出, 操作历史命令分为三步:</p>
<ol>
<li>首先从历史命令列表中选择某条命令, 被选择到的命令被称作 事件(event) (对应上面的!!)</li>
<li>再从选择好的事件中选择一部分单词(words), 事件中的每个单词以空格分割(对应上面的*)</li>
<li>最后对选择好的一部分单词进行修改(Modifiers)</li>
</ol>
<h2>2.2 事件指示器(Event Designators)</h2>
<p>事件指示器用来从历史命令列表中选择一条命令, 也就是选择事件</p>
<ul>
<li><p>!n<br>选择历史命令列表中第n条命令</p>
</li>
<li><p>!-n<br>选择倒数第n条命令</p>
</li>
<li><p>!!<br>选择上一条命令, 相当于!-1, 和 C-p 的作用也一样</p>
</li>
<li><p>!string<br>选择最近的以string开头的命令</p>
</li>
<li><p>!?string[?]<br>选择最近的包含string的命令, 如果该指示器后面是换行符, 则可以不用输入结尾的”?”</p>
</li>
<li><p>^string1^string2<br>取上一条命令, 并把第一个出现的string1替换成string2</p>
</li>
<li><p>!#<br>引用目前输入的所有命令, 比如输入:<code>more a !#</code><br>, 那么最终执行的命令就是:<code>more a more a</code></p>
</li>
</ul>
<h2>2.3 单词指示器(Word Designators)</h2>
<p>单词指示器用来从被选择好的事件中选择一部分单词, 单词指示器必须以冒号(:)和事件指示器分割开来, 除非单词指示器以^, $, *, -, %开头</p>
<ul>
<li><p>0<br>选择第0个word, 也就是命令. 假如事件为”ls abc”, 那么单词指示器0选择的word即为”ls”</p>
</li>
<li><p>n<br>选择第n个word</p>
</li>
<li><p>^<br>选择命令的第一个参数, 也就是第一个word, 相当于单词指示器1</p>
</li>
<li><p>$<br>选择命令的最后一个参数</p>
</li>
<li><p>%<br>选择最近的与 “?string?” 搜索相匹配的单词</p>
</li>
<li><p>x-y<br>选择第x到第y个word, -y表示0-y</p>
</li>
<li><p>*<br>选择命令的所有参数, 相当于1-$</p>
</li>
<li><p>x*<br>x-$的缩写</p>
</li>
<li><p>x-<br>类似x*, 不过不包含最后一个word. -选择除最后一个word外所有的words</p>
</li>
</ul>
<h2>2.4 修饰符(Modifiers)</h2>
<p>对选择的单词进行修改, 修饰符可以出现多次, 每个修饰符要以冒号开头</p>
<ul>
<li><p>p<br>打印新命令, 但不执行</p>
</li>
<li><p>s/old/new/<br>把 第一次出现的 old替换成new, 如果分隔符”/”是最后一个字符的话, 可以省略.<br>就像sed中一样, 分隔符”/”可以用其他字符代替, 比如s:old:new:. new中出现的<code>&amp;</code>将被old代替. 如果old省略, 那么就用上一次替换用的old代替.</p>
</li>
<li><p><code>&amp;</code><br>重复上一次替换</p>
</li>
<li><p>g<br>使修饰符所做的修改应用于整个选择的单词. 类似于sed中的s命令最后的g, 可配合:s和:&amp;修饰符使用, 比如:gs/old/new则对整个事件进行替换.</p>
</li>
<li><p>a<br>和g作用一样</p>
</li>
<li><p>G<br>使后面的:s修饰符对每个word只替换一次</p>
</li>
</ul>
<h2>2.5 例子</h2>
<h2>例一</h2>
<p>从别的机器的一个目录拷贝一个a.log文件, 执行:</p>
<pre><code>scp user<span class="variable">@machine</span><span class="symbol">:/home/user/a/a</span>.log .</code></pre>
<p>后来执行:</p>
<pre><code>ls <span class="transposed_variable">a.</span><span class="built_in">log</span>
rm -rf <span class="transposed_variable">a.</span><span class="built_in">log</span></code></pre>
<p>这时候再想拷贝一下b/b.log, 这时候就可以这样做:</p>
<pre><code><span class="change">!scp:gs/a/b</span></code></pre>
<p>如果只想看看用历史扩展出来的命令, 那可以这样:</p>
<pre><code>!<span class="symbol">scp:</span>gs/a/b/<span class="symbol">:p</span></code></pre>
<h2>例二</h2>
<p>从别的机器同时拷贝a/a.log和b/b.log:</p>
<pre><code>scp user<span class="variable">@mbchine</span><span class="symbol">:/home/user/a/a</span>.log . &amp;&amp; !<span class="comment">#-:gs/a/b</span></code></pre>
<p>上面的!#为事件指示器, 选择前面已经输入的命令<br><code>scp user@mbchine:/home/user/a/a.log . &amp;&amp;</code>, <code>-</code>为单词指示器,<br>选择除最后一个word, 即<code>&amp;&amp;</code>外的所有words, 也就是<br><code>scp user@mbchine:/home/user/a/a.log .</code>, 最后的<code>:gs/a/b</code>为修饰符, 对刚才选择的words进行全局替换, 把a替换成b, 最后就成了<br><code>scp user@mbchine:/home/user/b/b.log .</code>, 那么最终命令也就成了<br><code>scp user@mbchine:/home/user/a/a.log . &amp;&amp; scp user@mbchine:/home/user/b/b.log
.</code></p>
<h2>2.6 总结</h2>
<p>上面的例子都可以用前面所说的快捷键完成, 不过灵活利用历史扩展有时候还是能更高效的完成同样的事情</p>
<h1>3 shell技巧</h1>
<h2>3.1 Here Documents</h2>
<pre><code>&lt;<span class="xml"><span class="tag">&lt;<span class="title">[-]word
here-documents
delimiter</span></span></code></pre>
<p>把here-documents作为某个命令的标准输入, 例子:</p>
<pre><code><span class="title">grep</span> a &lt;&lt; <span class="type">EOF</span>
<span class="title">asdf</span>
<span class="title">qweszd</span>
<span class="title">asdf</span>
<span class="type">EOF</span></code></pre>
<h2>3.2 Here Strings</h2>
<pre><code>&lt;<span class="xml"><span class="tag">&lt;<span class="title">&lt;</span> <span class="attribute">here-strings</span></span></code></pre>
<p>把word作为命令的标准输入, 例子:</p>
<pre><code>grep a &lt;<span class="xml"><span class="tag">&lt;<span class="title">&lt;</span> <span class="attribute">abc</span></span></code></pre>
<h2>3.3 进程替换(Process Substitution)</h2>
<p>假如我现在想比较两个目录dir1和dir2中的文件有啥不同, 我想很多人会这样做:</p>
<pre><code><span class="title">ls</span> dir1 &gt; <span class="number">1</span>
<span class="title">ls</span> dir2 &gt; <span class="number">2</span>
<span class="title">diff</span> <span class="number">1</span> <span class="number">2</span></code></pre>
<p>但你试试这样:</p>
<pre><code>diff <span class="tag">&lt;<span class="title">(ls</span> <span class="attribute">dir1</span>) &lt;(<span class="attribute">ls</span> <span class="attribute">dir2</span>)</code></pre>
<p>是不是也可以? 很神奇吧. 上面的这个语法<code>&lt;(command)</code>就是进程替换.<br><code>&lt;(command)</code>表示把command的输出生成一个临时文件,<br>并把这个文件名作为另外一个命令的参数. 对于上面的命令, 就是把<br><code>ls dir1</code>命令的输出生成一个临时文件, 并把临时文件名做为diff命令的第一个参数. 再举一个例子:</p>
<pre><code><span class="title">wget</span> -q -O &gt;(cat) <span class="url">http://baidu.com</code></pre>
<p>wget命令会把下载后的文件保存到文件中去,<br>    但是我们可以用上面的命令不让它保存到文件中去, 而是显示出来.<br>    wget的<code>-O</code>选项后本来应该是一个文件名的参数, 但是我们现在用<code>&gt;(cat)</code>代替, 表示wget下载下来的内容放到一个临时文件中, 然后把这个临时文件名再传给&gt;()里面的cat命令.</p>
<p>灵活运用进程替换, 将会非常的方便, 严重推荐</p>

      
    </div>
    <footer>
      
        
  
  <div class="categories">
    <a href="/categories/linux/">linux</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/linux/">linux</a>, <a href="/tags/bash/">bash</a>, <a href="/tags/shell/">shell</a>
  </div>

        
  <div class="addthis addthis_toolbox addthis_default_style">
    
      <a class="addthis_button_facebook_like" fb:like:layout="button_count"></a>
    
    
      <a class="addthis_button_tweet"></a>
    
    
      <a class="addthis_button_google_plusone" g:plusone:size="medium"></a>
    
    
      <a class="addthis_button_pinterest_pinit" pi:pinit:layout="horizontal"></a>
    
    <a class="addthis_counter addthis_pill_style"></a>
  </div>
  <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js"></script>

      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


<section id="comment">
  <h1 class="title">留言</h1>

  
      <div id="fb-root"></div>
<script>
  (function(d, s, id) {
    var js, fjs = d.getElementsByTagName(s)[0];
    if (d.getElementById(id)) return;
    js = d.createElement(s); js.id = id;
    js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=123456789012345";
    fjs.parentNode.insertBefore(js, fjs);
  }(document, 'script', 'facebook-jssdk'));
</script>

<div class="fb-comments" data-href="http://whatot.github.io/pub/linux/linux/转:高效操作bash/" data-num-posts="5" data-width="840" data-colorscheme="light"></div>
      
  
</section>
</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:whatot.github.io">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/algorithm/">algorithm</a><small>1</small></li>
  
    <li><a href="/categories/basis/">basis</a><small>1</small></li>
  
    <li><a href="/categories/c/">c</a><small>3</small></li>
  
    <li><a href="/categories/database/">database</a><small>6</small></li>
  
    <li><a href="/categories/fun/">fun</a><small>1</small></li>
  
    <li><a href="/categories/git/">git</a><small>1</small></li>
  
    <li><a href="/categories/kernel/">kernel</a><small>3</small></li>
  
    <li><a href="/categories/linux/">linux</a><small>6</small></li>
  
    <li><a href="/categories/linux_program/">linux_program</a><small>3</small></li>
  
    <li><a href="/categories/program/">program</a><small>1</small></li>
  
    <li><a href="/categories/python/">python</a><small>1</small></li>
  
    <li><a href="/categories/thought/">thought</a><small>2</small></li>
  
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/CPU/">CPU</a><small>1</small></li>
  
    <li><a href="/tags/Makefile/">Makefile</a><small>1</small></li>
  
    <li><a href="/tags/algorithm/">algorithm</a><small>1</small></li>
  
    <li><a href="/tags/bash/">bash</a><small>1</small></li>
  
    <li><a href="/tags/c/">c</a><small>3</small></li>
  
    <li><a href="/tags/cache/">cache</a><small>1</small></li>
  
    <li><a href="/tags/career/">career</a><small>1</small></li>
  
    <li><a href="/tags/database/">database</a><small>6</small></li>
  
    <li><a href="/tags/fun/">fun</a><small>1</small></li>
  
    <li><a href="/tags/git/">git</a><small>1</small></li>
  
    <li><a href="/tags/kernel/">kernel</a><small>4</small></li>
  
    <li><a href="/tags/language/">language</a><small>4</small></li>
  
    <li><a href="/tags/linux/">linux</a><small>8</small></li>
  
    <li><a href="/tags/make/">make</a><small>1</small></li>
  
    <li><a href="/tags/math/">math</a><small>1</small></li>
  
    <li><a href="/tags/perf/">perf</a><small>1</small></li>
  
    <li><a href="/tags/program/">program</a><small>7</small></li>
  
    <li><a href="/tags/python/">python</a><small>1</small></li>
  
    <li><a href="/tags/regex/">regex</a><small>1</small></li>
  
    <li><a href="/tags/shell/">shell</a><small>6</small></li>
  
    <li><a href="/tags/thought/">thought</a><small>2</small></li>
  
    <li><a href="/tags/vim/">vim</a><small>1</small></li>
  
  </ul>
</div>


  
<div class="widget tagcloud">
  <h3 class="title">标签云</h3>
  <div class="entry">
    <a href="/tags/CPU/" style="font-size: 10.00px;">CPU</a><a href="/tags/Makefile/" style="font-size: 10.00px;">Makefile</a><a href="/tags/algorithm/" style="font-size: 10.00px;">algorithm</a><a href="/tags/bash/" style="font-size: 10.00px;">bash</a><a href="/tags/c/" style="font-size: 13.33px;">c</a><a href="/tags/cache/" style="font-size: 10.00px;">cache</a><a href="/tags/career/" style="font-size: 10.00px;">career</a><a href="/tags/database/" style="font-size: 16.67px;">database</a><a href="/tags/fun/" style="font-size: 10.00px;">fun</a><a href="/tags/git/" style="font-size: 10.00px;">git</a><a href="/tags/kernel/" style="font-size: 15.00px;">kernel</a><a href="/tags/language/" style="font-size: 15.00px;">language</a><a href="/tags/linux/" style="font-size: 20.00px;">linux</a><a href="/tags/make/" style="font-size: 10.00px;">make</a><a href="/tags/math/" style="font-size: 10.00px;">math</a><a href="/tags/perf/" style="font-size: 10.00px;">perf</a><a href="/tags/program/" style="font-size: 18.33px;">program</a><a href="/tags/python/" style="font-size: 10.00px;">python</a><a href="/tags/regex/" style="font-size: 10.00px;">regex</a><a href="/tags/shell/" style="font-size: 16.67px;">shell</a><a href="/tags/thought/" style="font-size: 11.67px;">thought</a><a href="/tags/vim/" style="font-size: 10.00px;">vim</a>
  </div>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2013 whatot
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>