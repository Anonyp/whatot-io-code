<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>转:Linux下文本的高效处理 | Whatot 日常积累</title>
  <meta name="author" content="whatot">
  
  <meta name="description" content="whatot blog">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="转:Linux下文本的高效处理"/>
  <meta property="og:site_name" content="Whatot 日常积累"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Whatot 日常积累" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Whatot 日常积累</a></h1>
  <h2><a href="/">积累每一天，无论是技术还是生活</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">主页</a></li>
    
      <li><a href="/archives">存档</a></li>
    
      <li><a href="/links">链接</a></li>
    
      <li><a href="/tools">工具集</a></li>
    
      <li><a href="/about">关于</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2013-07-27T04:11:24.000Z"><a href="/pub/linux/转Linux下文本的高效处理/">7月 27 2013</a></time>
      
      
  
    <h1 class="title">转:Linux下文本的高效处理</h1>
  

    </header>
    <div class="entry">
      
        <p>原文来源：<a href="http://ahei.info/text-processing.htm" target="_blank"><a href="http://ahei.info/text-processing.htm">http://ahei.info/text-processing.htm</a></a></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
</pre></td><td class="code"><pre>    <span class="number">1</span> 引言
    <span class="number">2</span> 关于输入
    <span class="number">3</span> 文本输出
        <span class="number">3.1</span> 整个输出
        <span class="number">3.2</span> 部分输出
    <span class="number">4</span> 文本搜索
        <span class="number">4.1</span> <span class="keyword">grep</span> (Global Regular Expression Print)
        <span class="number">4.2</span> fgrep
        <span class="number">4.3</span> egrep
        <span class="number">4.4</span> rgrep
        <span class="number">4.5</span> agrep (approximate <span class="keyword">grep</span>)
        <span class="number">4.6</span> zgrep
        <span class="number">4.7</span> sgrep (structured <span class="keyword">grep</span>)
        <span class="number">4.8</span> nrgrep (Nondeterministic Reverse <span class="keyword">grep</span>)
    <span class="number">5</span> 文本摘要
        <span class="number">5.1</span> wc (word count)
        <span class="number">5.2</span> md5sum
    <span class="number">6</span> 排序去重
        <span class="number">6.1</span> <span class="keyword">sort</span>
        <span class="number">6.2</span> tsort (topological <span class="keyword">sort</span>)
        <span class="number">6.3</span> uniq
        <span class="number">6.4</span> comm
        <span class="number">6.5</span> shuf (shuffle)
    <span class="number">7</span> 操作字段
        <span class="number">7.1</span> cut
        <span class="number">7.2</span> paste
        <span class="number">7.3</span> <span class="keyword">join</span>
    <span class="number">8</span> 操作字符
        <span class="number">8.1</span> <span class="keyword">tr</span> (translate)
        <span class="number">8.2</span> expand
        <span class="number">8.3</span> unexpand
        <span class="number">8.4</span> colrm (COLumn ReMove)
    <span class="number">9</span> 文本切割
        <span class="number">9.1</span> <span class="keyword">split</span>
        <span class="number">9.2</span> csplit (context <span class="keyword">split</span>)
    <span class="number">10</span> 文本编码
        <span class="number">10.1</span> iconv
        <span class="number">10.2</span> enca
    <span class="number">11</span> 文本格式化
        <span class="number">11.1</span> column
        <span class="number">11.2</span> fold
        <span class="number">11.3</span> fmt
    <span class="number">12</span> 微语言
        <span class="number">12.1</span> sed (Stream EDitor)
        <span class="number">12.2</span> awk (Alfred V. Aho, Peter J. Weinberger, Brian W. Kernighan.)
    <span class="number">13</span> 语言
    <span class="number">14</span> 实例
        <span class="number">14.1</span> 我的正则会数学
    <span class="number">15</span> 参考文献
</pre></td></tr></table></figure>

<a id="more"></a>


<h1>1 引言</h1>
<p>所谓的文本处理是指对文本进行查找、替换、删除、排序等操作, linux在文本处理方面提供了大量优秀的工具, 使得在linux下进行文本处理极其的方便.</p>
<p>我们平常的工作中, 经常会用到文本处理, 比如日志分析, 比如文本抽取, 等等, 所以掌握好文本处理, 将会对我们的工作起到极大的作用.</p>
<p>下面我就来逐个介绍下这些强大的工具, 对于我觉得大家可能比较熟知的工具及用法, 我会略过, 或者粗讲下.</p>
<h1>2 关于输入</h1>
<p>Linux哲学中, 为了更好的组合各种命令达到更加强大的功能, 大多数文本处理命令的输入既可以是文件, 也可以是标准输入, 如果没有指定输入文件, 则默认从标准输入读数据. 输出都是标准输出, 方面传给管道线的下一个命令, 想要输出到文件的话, 重定向下即可. 下面介绍的这些命令, 如无特殊说明, 则都可以从文件或者标准输入读入数据.</p>
<h1>3 文本输出</h1>
<h2>3.1 整个输出</h2>
<h3>echo</h3>
<blockquote>
<p>输入为命令行参数</p>
</blockquote>
<p>非常常用的命令, 主要用作输出字符串. 如果只是为了向管道线的下一个命令传输入的话, 可以使用Here String:</p>
<pre><code>echo xxx | md5sum
md5sum &lt;<span class="xml"><span class="tag">&lt;<span class="title">&lt;</span> <span class="attribute">xxx</span></span></code></pre>
<p>后者速度上应该会快一点, 不需要经过管道.</p>
<ul>
<li>-n<br>不输出换行符(默认输出换行符)</li>
<li>-e<br>解释转义符, 常用的转义符 \t, \n; 这个命令还有个最常用的用途就是输出ANSI颜色:<br><code>echo -e &#39;\033[1;31mHello, \033[0m\033[1;33mworld!\033[0m&#39;</code></li>
<li>-E<br>不解释转义符</li>
</ul>
<h3>printf</h3>
<blockquote>
<p>输入为命令行参数</p>
</blockquote>
<p>更强大的输出你想要的文本的命令, 类似C里面的printf</p>
<p><code>printf &#39;\033[1;31m%s, \033[0m\033[1;33m%d\033[0m and \u4e2d\u6587!\n&#39; &quot;Hello&quot; 34</code></p>
<p>不过此命令较echo来说, 使用率会低很多, 大多数情况下echo就能搞定了.</p>
<h3>yes [STRING]</h3>
<blockquote>
<p>输入为命令行参数</p>
</blockquote>
<p>不停的输出字符串STRING, 默认是y. 这个命令用处比较少, 但会有用, 比如测试tail命令.</p>
<h3>cat (concatenate)</h3>
<p>此命令最大的用途应该就是显示特殊字符了, 如果你告诉我你经常用它给管道线的下一个命令传输入的话, 那么就太浪费了:</p>
<pre><code><span class="title">cat</span> file | grep xxx
<span class="title">grep</span> xxx file</code></pre>
<p>前者相比后者多启动了一个进程, 还经过了管道. file很大的话, 性能差距很容易就看出来了.</p>
<ul>
<li>-E<br>在行尾显示$, 有时候行尾是空格或者TAB, 看不清行尾是哪里, 加了这个选项就知道了</li>
<li>-T<br>输出的时候用^I代替TAB符号, 这样很容易知道那一坨空白到底谁是TAB了</li>
<li>-v<br>用^和M-表示法输出不可打印字符<br><code>taoshanwen@taoshanwen-laptop ~$ echo -e &#39;\r&#39; | cat -v</code></li>
<li>-e<br>相当于-vE</li>
<li>-t<br>相当于-vT</li>
<li>-A<br>相当于-vET, 一般这个选项用的最多</li>
<li>-n<br>显示行号, 应该有同学感兴趣</li>
<li>-b<br>只对非空行显示行号, 有人感兴趣吗?</li>
<li>-s<br>对连续的空行只输出一个空行, 见过好多同学有这样的需求</li>
</ul>
<h3>tac</h3>
<p>看名字知道了, 它和cat是反的, 倒着输出, 先输出最后一行, 接着是倒数第二行, 最后输出的是第一行</p>
<ul>
<li>-s, —separator=STRING<br>设定分隔符, 代替\n分割文本</li>
</ul>
<h3>rev (reverse)</h3>
<p>这个命令和cat也是反的, 不过它不像tac那样, 它输出行的顺序和cat也是一样的, 不过输出每行的时候, 先输出最后一个字符, 接着是倒数第二个字符, 最后才是第一个字符, 下面这个命令可以把输入全部倒过来:</p>
<p>tac | rev</p>
<h3>nl (number lines)</h3>
<p>更强大的行号显示工具, 可以控制行号的格式, 宽度. 没有特殊的需求, 用cat -n就够了.</p>
<h2>3.2 部分输出</h2>
<h3>head</h3>
<p>只显示文本的开头几行, 比如head -2只显示前面2行</p>
<h3>tail</h3>
<p>这个命令相对head来说, 最常用的用途就是不停的打印文件的最新内容了(tail -f)</p>
<ul>
<li>-n, -K, —lines=K<br>显示尾部K行, -n +K显示第K行到文本尾部的所有内容</li>
<li>-f, —follow[={name|descriptor}]<br>这个选项表示如果文件尾部有新数据追加进来, 也会显示出来. 这个选项可以根据文件名(name)和文件描述符(descriptor)来监视文件是否有更新. 默认是descriptor.</li>
<li>—retry<br>当文件不可访问时, 进行重试, 这个选项和—follow=name组合起来比较有用</li>
<li>-F<br>相当于—follow=name —retry</li>
</ul>
<h1>4 文本搜索</h1>
<h2>4.1 grep (Global Regular Expression Print)</h2>
<p>非常常用的命令, 打印文本中匹配模式的行, 下面的选项最好都能掌握.</p>
<blockquote>
<p>grep [OPTIONS] PATTERN [FILE…]<br>grep [OPTIONS] [-e PATTERN | -f FILE] [FILE…]</p>
</blockquote>
<ul>
<li>-E, —extended-regexp</li>
</ul>
<p>使用扩展正则表达式(ERE), 默认的是基础正则表达式(BRE), BRE中元字符?, +, {, |, (, )失去特殊意义(你是否遇到grep “a|b”是否不能打印出含有a或者b的行?), 想要表达特殊意义的话, 需要用转义字符进行转义(), \?, +等</p>
<ul>
<li>-F, —fixed-strings</li>
</ul>
<p>把pattern当作一个固定的字符串, 不进行正则解析. 当你要搜索非正则的固定字符串时(还可能含有正则元字符), 这个选项会非常有用, 而且由于不需要解析正则, 速度会快些.</p>
<ul>
<li>-P, —perl-regexp</li>
</ul>
<p>把pattern解析为perl的正则(PCRE), 由于perl的正则强大而简洁, 所以可以多尝试着使用这个选项.</p>
<ul>
<li>-i, —ignore-case</li>
</ul>
<p>搜索pattern的时候, 忽略大小写. 如果没有这个选项, 可以使用PCRE, 比如:<br><code>grep -P &quot;(?i)AB&quot;</code></p>
<ul>
<li>-v, —invert-match</li>
</ul>
<p>显示不能匹配pattern的行</p>
<ul>
<li>-e pattern</li>
</ul>
<p>如果你想要指定多个搜索pattern, 或者你想要搜索的pattern由减号(-)开头(如果直接grep pattern的话, 会被解析为grep的选项), 就可以用这个选项了.</p>
<ul>
<li>-f FILE, —file=FILE</li>
</ul>
<p>从文件中获取pattern, 每行一个pattern</p>
<ul>
<li>-x, —line-regexp</li>
</ul>
<p>pattern必须要匹配整行, 这个选项等价于 “^pattern$”</p>
<ul>
<li>-w, —word-regexp</li>
</ul>
<p>pattern必须要匹配整个单词, 这个选项等价于 &quot;\bpattern\b&quot;</p>
<ul>
<li>-c, —count</li>
</ul>
<p>不打印匹配的行, 只打印匹配的行数, 等价于<code>grep pattern | wc -l</code></p>
<ul>
<li>—color[=WHEN], —colour[=WHEN]</li>
</ul>
<p>用颜色高亮出匹配的</p>
<ul>
<li>-m NUM, —max-count=NUM</li>
</ul>
<p>当发现NUM个匹配行后, 停止扫描剩下的文本.</p>
<ul>
<li>-q, —quiet, —silent</li>
</ul>
<p>不打印任何信息, 发现匹配即退出, 并返回0, 否则返回1. 我们经常只是想查看整个文本里面是否有匹配, 这时候这个选项就非常有用了, 速度会快很多.</p>
<ul>
<li>-o, —only-matching</li>
</ul>
<p>只显示匹配pattern的字符串, 匹配行的其余部分不显示</p>
<ul>
<li>-n, —line-number</li>
</ul>
<p>在匹配行前面打印行号</p>
<p>有时候想看看匹配行周围都是啥, 下面这几个选项就非常有用了:</p>
<ul>
<li>-A NUM, —after-context=NUM</li>
</ul>
<p>打印匹配行的后面NUM行</p>
<ul>
<li>-B NUM, —before-context=NUM</li>
</ul>
<p>打印匹配行的前面NUM行</p>
<ul>
<li>-C NUM, -NUM, —context=NUM</li>
</ul>
<p>打印匹配行的周围NUM行</p>
<ul>
<li>-a, —text</li>
</ul>
<p>有时候文件中含有一些非可打印字符, grep可能会把它识别成二进制文件, 这时候grep只会打印出是否匹配pattern的信息, 并不会打印匹配的每行, 这个选项会强制grep把该文件当文本文件处理</p>
<ul>
<li>-R, -r, —recursive</li>
</ul>
<p>递归处理文件夹下的所有文件</p>
<ul>
<li>-l, —files-with-matches</li>
</ul>
<p>不打印匹配的行, 只打印匹配的文件</p>
<ul>
<li>-L, —files-without-match</li>
</ul>
<p>和-l相反, 不打印匹配的行, 只打印不匹配的文件</p>
<ul>
<li>-h, —no-filename</li>
</ul>
<p>搜索多个文件时, 会在每行前面输出文件名, 如果你不喜欢, 使用此选项吧.</p>
<h2>4.2 fgrep</h2>
<p>grep -F</p>
<h2>4.3 egrep</h2>
<p>grep -E</p>
<h2>4.4 rgrep</h2>
<p>grep -r</p>
<h2>4.5 agrep (approximate grep)</h2>
<p>grep的模糊匹配版本</p>
<h2>4.6 zgrep</h2>
<p>对压缩文件进行grep, 接受的选项和grep完全一样</p>
<h2>4.7 sgrep (structured grep)</h2>
<p>对结构化的文本, 如SGML、XML、HTML进行搜索、抽取, 功能非常强大</p>
<h2>4.8 nrgrep (Nondeterministic Reverse grep)</h2>
<p>类似agrep</p>
<h1>5 文本摘要</h1>
<h2>5.1 wc (word count)</h2>
<p>最主要的用途就是统计行数</p>
<ul>
<li>-l, —lines</li>
</ul>
<p>最常用的选项, 统计行数</p>
<ul>
<li>-L, —max-line-length</li>
</ul>
<p>输出文本最长行的长度</p>
<ul>
<li>-w, —words</li>
</ul>
<p>输出单词数</p>
<ul>
<li>-m, —chars</li>
</ul>
<p>输出字符数</p>
<ul>
<li>-c, —bytes</li>
</ul>
<p>输出字节数</p>
<h2>5.2 md5sum</h2>
<p>打印文本的md5, 主要用作文件校验, 防止文件传输时发生错误或者被篡改. -c选项检查md5是否正确</p>
<h1>6 排序去重</h1>
<h2>6.1 sort</h2>
<p>非常常用的命令, 啥序都能排</p>
<ul>
<li>-r, —reverse</li>
</ul>
<p>逆序排序, 默认是按从小到大排, -r后就从大到小了</p>
<ul>
<li>-c, —check, —check=diagnose-first</li>
</ul>
<p>检查输入文件是否是有序的, 不是的话, 会打印哪行开始不是有序的</p>
<ul>
<li>-C, —check=quiet, —check=silent</li>
</ul>
<p>类似-c, 但是不打印错误信息, 只返回错误码1</p>
<ul>
<li>-k, —key=POS1[,POS2]</li>
</ul>
<p>这个应该是sort最nb的地方了, 可以精确控制要排序的对象. POS具备这样的形式:</p>
<p><code>F[.C][OPTS]</code></p>
<p>其中, F是字段号, C是字符号, OPTS是排序选项, 可以每个字段排序的规则不一样. F, C都是从1开始</p>
<pre><code><span class="title">sort</span> -t<span class="string"> ' '</span> -k1,<span class="number">1</span>d -k2<span class="number">.2</span>,<span class="number">2</span>n &lt;&lt;-<span class="type">EOF</span>
<span class="title">bb</span> <span class="number">113</span>
<span class="title">aa</span> <span class="number">224</span>
<span class="title">cc</span> <span class="number">323</span>
<span class="title">dd</span> <span class="number">444</span>
<span class="title">cc</span> <span class="number">513</span>
<span class="type">EOF</span>

<span class="title">aa</span> <span class="number">224</span>
<span class="title">bb</span> <span class="number">113</span>
<span class="title">cc</span> <span class="number">513</span>
<span class="title">cc</span> <span class="number">323</span>
<span class="title">dd</span> <span class="number">444</span></code></pre>
<ul>
<li>-u, —unique</li>
</ul>
<p>对输出结果进行去重, 只输出重复的记录中的第一条记录</p>
<ul>
<li>-m, —merge</li>
</ul>
<p>对有序的输入文件进行归并, 这个选项使得你能够在多核机器上优化大数据集的排序</p>
<ul>
<li>-s, —stable</li>
</ul>
<p>使得sort成为稳定排序</p>
<ul>
<li>-T, —temporary-directory=DIR</li>
</ul>
<p>设定指定的临时文件夹, 存放中间数据. 当你排序非常大的文件时, 而且/tmp所在的分区空间不够时, 就会用到该选项了</p>
<ul>
<li>-n, —numeric-sort</li>
</ul>
<p>把输入当整数来排序, 可以有负数, 但是不能含有加号(+)的正数, 这种输入用-g搞定吧</p>
<ul>
<li>-g, —general-numeric-sort</li>
</ul>
<p>把输入当作数值来排序, 可以有浮点数. 如果输入是整数的话, 就用-n搞定吧, 人家性能高些.</p>
<ul>
<li>-h, —human-numeric-sort</li>
</ul>
<p>可以排序2K, 1G等带单位的数字, 很爽啊, 想排序某文件夹下所有文件和文件的大小吗:<br><code>du -sh * | sort -h</code></p>
<ul>
<li>-M, —month-sort</li>
</ul>
<p>按月份进行排序, <code>&#39;JAN&#39;&lt; &#39;FEB&#39; &lt; … &lt; &#39;DEC&#39;</code></p>
<ul>
<li>-d, —dictionary-order</li>
</ul>
<p>按字典序排序, 忽略字母、数字、空白字符外的所有字符</p>
<ul>
<li>-V, —version-sort</li>
</ul>
<p>你开发的软件有很多版了没? 排下吧, 根据版本号</p>
<ul>
<li>-t, —field-separator=SEP</li>
</ul>
<p>设置字段分隔符, 默认为空白字符. 可惜的是, 这个字段分隔符只能为单个字符</p>
<ul>
<li>-b, —ignore-leading-blanks</li>
</ul>
<p>忽略前导空白字符</p>
<ul>
<li>-f, —ignore-case</li>
</ul>
<p>忽略大小写</p>
<ul>
<li>-i, —ignore-nonprinting</li>
</ul>
<p>忽略不可打印字符</p>
<ul>
<li>-R, —random-sort</li>
</ul>
<p>随机排序, 我想你会用到它的, 反正我用过几次. 不过排序结果不完全随机,<br>    因为sort会先对每行进行hash, 然后对hash值进行排序,<br>    所以相同的行一定会排到一块. 不过也许, 这正是你想要的.<br>        如果你想更乱或者更加强大的功能的话, 看<br>        <code>shuf (shuffle)</code></p>
<ul>
<li>陷阱</li>
</ul>
<p>你是否经常sort一个中文文件却得不到正确结果? 那就对了, 你肯定没设置好语言环境(locale), 试试LC_ALL=C sort吧. sort会根据本地语言环境对输入文本进行排序. LC_ALL=C表示会根据字节值来排序. 或许你说我怎么见到的都是LANG=C sort啊, 来, 我们看看bash info上关于LANG和LC_ALL的解释:</p>
<blockquote>
<p>LANG   Used to determine the locale category for any category not specifically selected with a variable starting with LC<em>.<br>LC_ALL This variable overrides the value of LANG and any other LC</em> variable specifying a locale category.<br>LC_COLLATE<br>   This variable determines the collation order used when sorting the results of pathname expansion, and  determines  the behavior  of  range  expressions,  equivalence  classes, and collating sequences within pathname expansion and pattern matching.</p>
</blockquote>
<pre><code><span class="bullet">* </span>LANG
如果你没有用LC_来设定某个分类的locale, 将会使用LANG来决定这个分类的locale
<span class="bullet">* </span>LC_ALL
该变量会覆盖LANG和LC_
<span class="bullet">* </span>LC_COLLATE
该变量设置排序时的locale</code></pre>
<p>所以, sort时, 设置LC_ALL是最保险的做法.</p>
<h2>6.2 tsort (topological sort)</h2>
<p>拓朴排序, 该命令可能会用的比较少</p>
<pre><code>$ tsort &lt;<span class="xml"><span class="tag">&lt;<span class="title">EOF
a</span> <span class="attribute">b</span> <span class="attribute">c</span>
<span class="attribute">d</span>
<span class="attribute">e</span> <span class="attribute">f</span>
<span class="attribute">b</span> <span class="attribute">c</span> <span class="attribute">d</span> <span class="attribute">e</span>
<span class="attribute">EOF</span></span></code></pre>
<p>输出:</p>
<pre><code><span class="title">a</span>
<span class="title">b</span>
<span class="title">c</span>
<span class="title">d</span>
<span class="title">e</span>
<span class="title">f</span></code></pre>
<h2>6.3 uniq</h2>
<p>也是非常常用的一个命令. 这个命令主要用来对有序序列进行去重, 所以它常和sort联合起来使用, 但是sort -u本身就有去重的功能, 所以当你仅仅只是为了去重时, sort -u就可以帮你搞定了(当输入文本巨大时, 可以用hash来去重提高性能, 比如awk的关联数组), 所以呢, 当年需要对重复的数据进行统计时, 会用到uniq. 当然其实uniq相比sort -u而言, 对重复数据有更加强大的处理</p>
<ul>
<li>-c, —count</li>
</ul>
<p>在每行文本前面输出重复次数</p>
<ul>
<li>-d, —repeated</li>
</ul>
<p>只显示重复的行, 重复的行只显示一行</p>
<ul>
<li>-D, —all-repeated[=delimit-method]</li>
</ul>
<p>显示所有重复的行, 注意该选项与选项-d的区别</p>
<ul>
<li>-u, —unique</li>
</ul>
<p>只打印不重复的行</p>
<ul>
<li>-i, —ignore-case</li>
</ul>
<p>比较的时候不区分大小写</p>
<ul>
<li>-f, —skip-fields=N</li>
</ul>
<p>不比较前面N个字段, 字段分隔符为空白字符</p>
<ul>
<li>-s, —skip-chars=N</li>
</ul>
<p>不比较前面N个字符</p>
<ul>
<li>-w, —check-chars=N</li>
</ul>
<p>每行最多比较前面N个字符</p>
<ul>
<li>实例演示</li>
</ul>
<p>大家看了uniq上面几个选项后, 是不是有uniq没有太大用处的感觉? 这都是错觉, 下面我给大家演示下uniq在集合运算(统计中有大量的应用)方面巧妙的应用.</p>
<pre><code>* 并集 <span class="string">``</span><span class="keyword">sort</span> A B | uniq<span class="string">``</span>
* 交集 <span class="string">``</span><span class="keyword">sort</span> A B | uniq -d<span class="string">``</span>
* 差集(A-B) <span class="string">``</span><span class="keyword">sort</span> A B B | uniq -u<span class="string">``</span></code></pre>
<ul>
<li>缺陷<ul>
<li>不能控制字段分隔符</li>
<li>不能像sort -k那样精确的控制要比较的对象</li>
</ul>
</li>
</ul>
<h2>6.4 comm</h2>
<p>逐行比较两个有序文件, 分三列输出文件1独有的行、文件2独有的行、文件12共有的行,</p>
<pre><code>$ cat ab
<span class="title">ax</span>
<span class="title">by</span>
<span class="title">cz</span>

$ cat ac
<span class="title">ax</span>
<span class="title">bd</span>
<span class="title">cz</span>

$ comm ab ac
    ax
<span class="title">bd</span>
<span class="title">by</span>
    cz</code></pre>
<ul>
<li>-1</li>
</ul>
<p>不输出第一列(文件1独有的行)</p>
<ul>
<li>-2</li>
</ul>
<p>不输出第二列(文件2独有的行)</p>
<ul>
<li>-3</li>
</ul>
<p>不输出第三列文件3独有的行</p>
<ul>
<li>—check-order</li>
</ul>
<p>检查输入文件是否有序</p>
<ul>
<li>—nocheck-order</li>
</ul>
<p>不检查输入文件是否有序</p>
<ul>
<li>—output-delimiter=STR</li>
</ul>
<p>设定输出分隔符, 默认为TAB</p>
<ul>
<li>实例演示<ul>
<li>交集 <code>comm -12 &lt;(sort A) &lt;(sort B)</code></li>
<li>差集(A-B) <code>comm -23 &lt;(sort A) &lt;(sort B)</code></li>
</ul>
</li>
</ul>
<h2>6.5 shuf (shuffle)</h2>
<p>如果<code>sort -R</code>产生的结果还不够乱的话, 我想这个命令应该就是你需要的了.<br>该命令产生完全乱序的结果, 而且速度应该比<code>sort -R</code>快(shuf不用排序), 还有功能更强大</p>
<ul>
<li>-e, —echo</li>
</ul>
<p>对命令行参数乱序</p>
<ul>
<li>-i, —input-range=LO-HI</li>
</ul>
<p>对LO到HI之间的数字进行乱序, 比如shuf -i 12-100</p>
<h1>7 操作字段</h1>
<h2>7.1 cut</h2>
<p>挺常用的一个命令, 能非常方便的取某个字段</p>
<ul>
<li>-f, —fields=LIST</li>
</ul>
<p>选择要输出的字段</p>
<ul>
<li>-c, —characters=LIST</li>
</ul>
<p>选择要输出的字符</p>
<ul>
<li>-b, —bytes=LIST</li>
</ul>
<p>选择要输出的字节</p>
<ul>
<li>-d, —delimiter=DELIM</li>
</ul>
<p>设定字段分隔符, 默认是TAB. 可惜的是, 该分隔符也只能是单个字符.</p>
<ul>
<li>—complement</li>
</ul>
<p>取设定的选择LIST的补集</p>
<ul>
<li>-s, —only-delimited</li>
</ul>
<p>忽略不包含分隔符的行, 默认操作是输出整行</p>
<ul>
<li>—output-delimiter=STRING</li>
</ul>
<p>设定输出分隔符</p>
<ul>
<li><p>LIST</p>
</li>
<li><p>-f, -c, -b选项使用的列表, 可以有下面几种形式:</p>
<ul>
<li>N<br>第N个字段/字节/字符</li>
<li>N-<br>从第N个到最后一个</li>
<li>M-N<br>从第M个到第N个</li>
<li>-M<br>从第一个到第N个</li>
</ul>
</li>
</ul>
<p>列表可以有多个, 之间以逗号分割, 比如:</p>
<p><code>cut -f1-3,4-7</code></p>
<h2>7.2 paste</h2>
<p>这个命令很有意思, 把两个文件按行粘贴到一块, 曾经我想自己写个程序搞定这个需求, 后来发现linux下竟然已经有这玩意了(linux总能给你带来惊喜)</p>
<pre><code><span class="variable">$ </span>cat num2
<span class="number">1</span>
<span class="number">2</span>
<span class="variable">$ </span>cat let3
a
b
c
<span class="variable">$ </span>paste num2 let3
<span class="number">1</span>       a
<span class="number">2</span>       b
    c</code></pre>
<ul>
<li>-d, —delimiters=LIST</li>
</ul>
<p>paste两个文件的时候, 默认是用TAB分割, 这个选项设定分隔符, 同为可惜的是, 只能为单个字符(主要是paste可以粘贴多个文件, 这个选项的第二个字符用来分割第二个和第三个文件)</p>
<ul>
<li>-s, —serial</li>
</ul>
<p>默认paste是竖着粘贴的, 加了这个选项后, 就横着粘贴了:</p>
<pre><code><span class="comment">$</span> <span class="comment">paste</span> <span class="literal">-</span><span class="comment">s</span> <span class="comment">num2</span> <span class="comment">let3</span>
<span class="comment">1</span>       <span class="comment">2</span>
<span class="comment">a</span>       <span class="comment">b</span>       <span class="comment">c</code></pre>
<h2>7.3 join</h2>
<p>这是一个稍微高级点的命令, 它把输入文件当成一个key/value对, 然后会把同一个key的所有value粘贴到一块, 来个例子:</p>
<pre><code>$ cat file1
<span class="title">a</span> <span class="number">1</span>
<span class="title">b</span> <span class="number">2</span>
<span class="title">c</span> <span class="number">3</span>
$ cat file2
<span class="title">a</span> <span class="number">4</span>
<span class="title">c</span> <span class="number">6</span>
$ join file1 file2
<span class="title">a</span> <span class="number">1</span> <span class="number">4</span>
<span class="title">c</span> <span class="number">3</span> <span class="number">6</span></code></pre>
<p>join默认把第一额字段当作key, 字段之间以空格分割, 作为key的字段必须有序.</p>
<ul>
<li>-i, —ignore-case</li>
</ul>
<p>比较字段时, 忽略大小写</p>
<ul>
<li>-t CHAR</li>
</ul>
<p>使用CHAR作为字段分隔符, 又是只能为单个字符(杯具…)</p>
<ul>
<li>-1 FIELD</li>
</ul>
<p>设定第一个文件的key为第FIELD个字段</p>
<ul>
<li>-2 FIELD</li>
</ul>
<p>设定第二个文件的key为第FIELD个字段</p>
<ul>
<li>-j FIELD</li>
</ul>
<p><code>-1 FIELD -2 FIELD</code></p>
<ul>
<li>-a FILENUM</li>
</ul>
<p>join默认只打印拥有相同key的行, 该选项会打印第FILENUM个文件中没有匹配上的行</p>
<ul>
<li>-v FILENUM</li>
</ul>
<p>和-a选项有点类似, 该选项只打印第FILENUM个文件中没有匹配上的行, 不会打印匹配上的行</p>
<ul>
<li>—check-order</li>
</ul>
<p>检查输入文件作为key的字段是否有序</p>
<ul>
<li>—nocheck-order</li>
</ul>
<p>不检查输入文件作为key的字段是否有序</p>
<ul>
<li>-o FIELD-LIST</li>
</ul>
<p>高级的控制输出对象的选项, FIELD-LIST中的每个元素具有下面这样的形式:</p>
<pre><code><span class="bullet">* </span>0
表示做为key的字段
<span class="bullet">* </span>M.N
M为文件号, 取值为0或者1, N为字段号, M.N就是取第M个文件第N个字段</code></pre>
<p>每个元素之间以逗号或者空格分割</p>
<ul>
<li><p>-e EMPTY</p>
<p>-o选项中, 可能文件M中没有字段号N, 这时候输出的时候用EMPTY代替.</p>
</li>
</ul>
<h1>8 操作字符</h1>
<h2>8.1 tr (translate)</h2>
<p>主要对文本中的字符进行替换、删除.</p>
<ul>
<li>该命令只支持标准输入, 不支持从文件输入.</li>
<li>tr仅支持单字节字符.</li>
</ul>
<blockquote>
<p>tr [OPTION]… SET1 [SET2]</p>
</blockquote>
<p>字符集合可以由一系列的字符构成, 也可以具有以下形式:</p>
<ul>
<li>CHAR1-CHAR2<br>从CHAR1到CHAR2的所有字符</li>
<li>[CHAR*]<br>这种形式只能出现在SET2中, 表示拷贝CHAR直到SET2和SET1的长度相等</li>
<li>[CHAR*REPEAT]<br>REPEAT个CHAR</li>
<li>[:alnum:]<br>所有的字母和数字</li>
<li>[:alpha:]<br>所有的字母</li>
<li>[=CHAR=]<br>和CHAR属于同一个字符类中的所有字符</li>
</ul>
<p>当提供2个字符集合时, 表示把SET1中的字符替换成SET2中的对应的字符, 比如:</p>
<pre><code><span class="keyword">tr</span> a A &lt; file <span class="comment"># 把文件file中的小写a都变成大写A</span>
<span class="keyword">tr</span> <span class="string">'[:lower:]'</span> <span class="string">'[:upper:]'</span> &lt; file <span class="comment"># 把文件file全部大写</span></code></pre>
<ul>
<li>-d, —delete</li>
</ul>
<p>删除出现在集合1中的所有字符. 下面的命令把文件file中所有的行连成一行:<br><code>tr -d &quot;\r\n&quot; &lt; file</code></p>
<ul>
<li>-s, —squeeze-repeats</li>
</ul>
<p>把SET1中连续的字符都替换成1个字符, 当SET2也提供时, 首先执行删除连续字符操作, 然后才执行替换操作</p>
<ul>
<li>-c, -C, —complement</li>
</ul>
<p>使用SET1的补集</p>
<ul>
<li>-t, —truncate-set1</li>
</ul>
<p>首先把SET1中的字符截断到和SET2长度相等</p>
<ul>
<li>陷阱</li>
</ul>
<p>经常见到有同学对会含有中文的文件用上面的方法进行大小写转换:</p>
<pre><code># 终端编码为GB18030编码
$ tr <span class="string">'[:upper:]'</span> <span class="string">'[:lower:]'</span> &lt;<span class="xml"><span class="tag">&lt;<span class="title">&lt;</span> 琄
琸</span></code></pre>
<p>为什么琄会变成琸呢?</p>
<p>上面我们说到, tr是按字节来处理的, 而GB18030编码第二个字节编码范围为0×40-0×7E和0×80-0×FE, 这样, 第二个字节就可能出现ASCII码, 我们来看下上面2个汉字的GB18030编码值:</p>
<pre><code><span class="xml">$ od -c  <span class="tag">&lt;<span class="title">&lt;&lt;</span> 琄
</span><span class="number">0000000</span><span class="xml"> </span><span class="number">254</span><span class="xml">   K  \n
</span><span class="number">0000003</span><span class="xml">
$ od -t x1  <span class="tag">&lt;<span class="title">&lt;&lt;</span> 琄
</span><span class="number">0000000</span><span class="xml"> ac </span><span class="number">4</span><span class="xml">b </span><span class="number">0</span><span class="xml">a
</span><span class="number">0000003</span><span class="xml">

$ od -c  <span class="tag">&lt;<span class="title">&lt;&lt;</span> 琸
</span><span class="number">0000000</span><span class="xml"> </span><span class="number">254</span><span class="xml">   k  \n
</span><span class="number">0000003</span><span class="xml">
$ od -t x1  <span class="tag">&lt;<span class="title">&lt;&lt;</span> 琸
</span><span class="number">0000000</span><span class="xml"> ac </span><span class="number">6</span><span class="xml">b </span><span class="number">0</span><span class="xml">a
</span><span class="number">0000003</span><span class="xml"></span></code></pre>
<p>看来确实如此, 琄的第二个字节是字符大K, 琸的第二个字节是字符小k.</p>
<p>看来, 如果文本里含有多字节字符, 使用tr的时候得小心咯.</p>
<h2>8.2 expand</h2>
<p>每个编辑器对TAB的显示设置不一样, 有的显示为8个字符, 有的显示为4个字符, 这样就造成了在A编辑器下排版很漂亮, 到了B编辑器下变得一团糟, 所以编码的时候最好使用空白字符代替TAB(Emacs中这样设置: (setq-default indent-tabs-mode nil), :) ), expand命令也可以帮你把TAB转换成空格</p>
<ul>
<li>-i, —initial</li>
</ul>
<p>不转换非空白字符后的TAB</p>
<ul>
<li>-t, —tabs=NUMBER</li>
</ul>
<p>设置一个TAB转换成几个空格, 默认是8</p>
<h2>8.3 unexpand</h2>
<p>Makefile缩进的时候, 必须是TAB, 所以有时候又需要把空格变成TAB, 就靠unexpand了</p>
<ul>
<li>-a, —all</li>
</ul>
<p>转换所有的空格, 默认情况下只转换开头的空格</p>
<ul>
<li>—first-only</li>
</ul>
<p>只转换开头的空格</p>
<ul>
<li>-t, —tabs=N</li>
</ul>
<p>几个空格转换成一个TAB, 默认是8</p>
<h2>8.4 colrm (COLumn ReMove)</h2>
<blockquote>
<p>colrm [start [stop]]</p>
</blockquote>
<p>该命令只支持标准输入, 不支持从文件输入.</p>
<p>删除每行从start到stop之间的字符, 如果stop没有指定的话, 则删除到末尾. 需要注意的是, TAB被认为占8列(不知道为啥这样搞)</p>
<h1>9 文本切割</h1>
<h2>9.1 split</h2>
<p>切割文本INPUT成文件PREFIXaa, PREFIXab … 默认每个文件1000行, PREFIX为x</p>
<blockquote>
<p>split [OPTION]… [INPUT [PREFIX]]</p>
</blockquote>
<ul>
<li>-l, —lines=NUMBER</li>
</ul>
<p>按行切割, 每个输出文件NUMBER行, 比较常用的切割方式</p>
<ul>
<li>-b, —bytes=SIZE</li>
</ul>
<p>按字节切分</p>
<ul>
<li>-C, —line-bytes=SIZE</li>
</ul>
<p>每个文件最多SIZE个自己, 但是每行都完整的保存到一个输出文件中, 即不像-b那样, 可能一个整行被拆分到多个文件中去</p>
<ul>
<li>-d, —numeric-suffixes</li>
</ul>
<p>使用数字做为后缀名</p>
<h2>9.2 csplit (context split)</h2>
<p>根据模式切割文件, 简单了解即可</p>
<blockquote>
<p>csplit [OPTION]… FILE PATTERN…</p>
</blockquote>
<h1>10 文本编码</h1>
<h2>10.1 iconv</h2>
<p>经常会用到, 主要用来转换编码</p>
<ul>
<li>—list, -l</li>
</ul>
<p>列出可以识别的编码</p>
<ul>
<li>-c</li>
</ul>
<p>转换的时候, 忽视无效的字符, 如果没有加这个选项, iconv碰到这个无效字符会直接报错退出, 所以最好加上这个选项</p>
<h2>10.2 enca</h2>
<p>我们经常需要知道文件的编码, 这个命令帮你搞定</p>
<h1>11 文本格式化</h1>
<p>打扮一下你的文本吧.</p>
<h2>11.1 column</h2>
<p>按列漂亮的输出:</p>
<p><code>$ (printf &quot;PERM LINKS OWNER GROUP SIZE DAY HH:MM NAME\n&quot;; ls -l | sed 1d) | column -t</code></p>
<h2>11.2 fold</h2>
<p>将一个比较长的文本行输出进行“折行”.</p>
<h2>11.3 fmt</h2>
<p>将输入按照指定宽度进行折行, 功能较fold强大些</p>
<h1>12 微语言</h1>
<p>下面介绍文本处理中两个最强大的命令sed和awk, 它们已经具有一些程序设计语言的特征了, 特别是awk, 所以, 我们的脚本中, 放眼望去, 皆是awk阿. 熟练掌握这两个命令, 你的文本处理功力将会极大的提升阿.</p>
<h2>12.1 sed (Stream EDitor)</h2>
<p>sed是一个流编辑器, 类似ed(行编辑器, 通过各种命令编辑文件), 它提供了各种替换、删除的命令, 使得这些编辑操作能自动化起来.</p>
<h3>工作流程</h3>
<p>sed维护2快内存(也可以理解为2个变量, 或者说是2个寄存器), 分别叫做 pattern space 和 hold space, sed对每行输入执行下面的循环:</p>
<ol>
<li>读入输入行, 去掉尾部的换行符, 存入pattern space</li>
<li>执行sed命令, 每条sed命令都可以有个地址与它关联, 这个地址就类似于条件语句, 只有这个条件语句通过验证时, 其对应的命令才会执行</li>
<li>执行完所有的sed命令后, 如果没有指定sed的-n选项, 将会打印pattern space的内容, 然后再输出换行符. 最后继续读入下一行, 进行下一次的循环</li>
</ol>
<p>每次循环开始时, pattern space的内容会被清空, hold space则不会</p>
<h3>地址格式</h3>
<p>sed地址可以具有以下的形式:</p>
<pre><code>* NUMBER
指定执行命令的行号, 只有在这行, 对应的命令才会被执行, 行号从<span class="number">1</span>开始, 另外, 如果没有指定-i或者-s选项的话, 所有的输入文件会被当成一个输入流, 行号就会一直累加的
* FIRST~<span class="keyword">STEP</span>
在FIRST、FIRST+<span class="keyword">STEP</span>、FIRST+<span class="number">2</span>*<span class="keyword">STEP</span>、、FIRST+<span class="number">3</span>*<span class="keyword">STEP</span>行执行对应的命令
* $
最后一行
* <span class="built_in">REGEXP</span>
在匹配上正则<span class="built_in">REGEXP</span>的行执行对应的命令, 如果<span class="built_in">REGEXP</span>中含有/, 需要用\转义
* \%<span class="built_in">REGEXP</span>%
在匹配上正则<span class="built_in">REGEXP</span>的行执行对应的命令, %也可以是其他字符, 如果<span class="built_in">REGEXP</span>中含有%, 需要用\转义
* /<span class="built_in">REGEXP</span>/I, \%<span class="built_in">REGEXP</span>%I
忽略大小写
* /<span class="built_in">REGEXP</span>/M, \%<span class="built_in">REGEXP</span>%M
可以匹配多行, M表示multi-line</code></pre>
<p>如果没有指定地址的话, 表示所有行对执行命令. 还可以提供2个地址, 指定一个地址范围, 这2个地址之间以逗号分割, 比如:<br><code>ADDRESS1,ADDRESS2</code></p>
<p>这样, 第一次匹配上ADDRESS1的行与第一次匹配上ADDRESS2的行之间的所有行都会执行对应的命令.</p>
<p>GNU sed还支持下面几种地址范围:</p>
<pre><code><span class="bullet">* </span>ADDR1,+N
匹配ADDR1, 以及接下来的N行
<span class="bullet">* </span>ADDR1,~N
匹配ADDR1, 直到行号为N倍数的行</code></pre>
<p>在地址或者地址范围后加感叹号(!), 表示取反.</p>
<h3>常用命令</h3>
<p>由于sed默认会打印pattern space, 所以不加任何命令的话, 就和cat一样, 打印所有的输出:</p>
<pre><code>$ cat ab
<span class="title">ab</span>
<span class="title">ab</span>
<span class="title">ac</span>
<span class="title">ad</span>
<span class="title">ae</span>
<span class="title">ac</span>
<span class="title">ab</span>

$ sed <span class="string">""</span> ab
<span class="title">ab</span>
<span class="title">ab</span>
<span class="title">ac</span>
<span class="title">ad</span>
<span class="title">ae</span>
<span class="title">ac</span>
<span class="title">ab</span></code></pre>
<ul>
<li>d</li>
</ul>
<p>删除pattern space, 立即进入下一轮循环.</p>
<p>ls输出的时候, 第一行有个摘要, 如果不想显示的话, 这样:</p>
<p><code>ls -l | sed 1d</code></p>
<ul>
<li>p</li>
</ul>
<p>打印pattern space.</p>
<p>输出文件ab第5到第10行:</p>
<p><code>sed -n 5,10p ab</code></p>
<ul>
<li>q [EXIT-CODE]</li>
</ul>
<p>立即以返回码EXIT-CODE(默认为0)退出sed, 如果没有加-n选项的话, 当前的模式空间也会打印出来.</p>
<p>如果文件很大的话, 下面的方法输出文件ab第5到第10行会快很多:</p>
<p><code>sed -n &quot;5,10p; 10q&quot; ab</code></p>
<ul>
<li>n</li>
</ul>
<p>如果没有加-n的话, 打印模式空间, 然后直接进入下一轮循环.</p>
<p>不打印第18行:</p>
<p><code>sed -n &quot;p; 18n&quot;</code></p>
<ul>
<li>{ COMMANDS }</li>
</ul>
<p>一组命令, 这组命令共用同一个地址.</p>
<p>打印第8行:</p>
<p><code>sed -n &quot;8 {p; q}&quot;</code></p>
<ul>
<li>s/REGEXP/REPLACEMENT/FLAGS</li>
</ul>
<p>这个命令估计是大家用的最多的命令了. 前面几个命令大家不知道的情况下, 可能通过其他命令解决了, 但是这个命令的功能除了awk, 其他的做不了, 而sed比awk更简洁.</p>
<p>这个命令主要是对pattern space进行替换, 对匹配REGEXP的部分用REPLACEMENT进行替换, 用来分割的/可以由其他字符组成, 比如s:REGEXP:REPLACEMENT:FLAGS. REPLACEMENT可以由原始的字符组成, 也可以由下面带有特殊意义的串组成:</p>
<pre><code>* <span class="special">&amp;</span>
匹配REGEXP的部分

* <span class="command">\d</span>
d为1-9的数字, <span class="command">\d</span>表示REGEXP中第d个括号匹配的部分, 比如REGEXP为:
``a(..(..))``
pattern space为abcde, 那么\1为bcde, \2为de

* <span class="command">\L</span>
把REPLACEMENT中的字符变成小写, 直到遇到<span class="command">\U</span>和<span class="command">\E</span>. 比如:

    <span class="formula">$ cat ab
    AB
    AB
    ac
    ad
    ae
    ac
    AB

    $</span> sed -r 's/(AB)/<span class="command">\L</span>\1YYY/' ab
    abyyy
    abyyy
    ac
    ad
    ae
    ac
    abyyy

上例中, 本来\1应该是AB, 但是<span class="command">\L</span>把它全变成小写了. 而且后面的YYY也变成小写了.
* <span class="command">\l</span>
把下一个字符变成小写

* <span class="command">\U</span>
把REPLACEMENT中的字符变成大写, 直到遇到<span class="command">\L</span>和<span class="command">\E</span>.

* <span class="command">\u</span>
把下一个字符变成大写

* <span class="command">\E</span>
结束<span class="command">\L</span>和<span class="command">\U</span>的作用</code></pre>
<p>s命令后的FLAGS可以由下面几种:<br>    <em> g<br>    s命令默认只替换第一个匹配, g可以让它全部替换
    </em> NUMBER<br>    替换第NUMBER个匹配<br>    <em> p<br>    如果发生了替换, 打印模式空间.<br>    搜索文件ab中xxx并替换成yyy打印出来:<br>    <code>sed s/xxx/yyy/p ab</code>
    </em> i, I<br>    正则匹配忽略大小写</p>
<ul>
<li>y/SOURCE-CHARS/DEST-CHARS/</li>
</ul>
<p>类似tr命令, 用DEST-CHARS对应的字符替换出现在SOURCE-CHARS中的字符. 和s命令一样, 分隔符/也可以是其他字符.</p>
<ul>
<li>=</li>
</ul>
<p>打印行号. 下面的命令类似grep -n:</p>
<p><code>sed  -n &#39;/xxx/ {=; p}&#39;</code></p>
<h3>高级命令</h3>
<ul>
<li>h<br>用pattern space替换hold space</li>
<li>H<br>先在hold space追加换行符, 再往hold space追加pattern space</li>
<li>g<br>用hold space替换pattern space</li>
<li>G<br>先在pattern space追加换行符, 再往pattern space追加hold space</li>
<li>x<br>交换pattern space和hold space的内容</li>
<li>D<br>删除模式空间的第一行. 如果模式空间中还有内容的话, 开始进入下一轮循环, 但不读入输入. 如果没有内容的话, 读入输入并进行下一轮循环.</li>
<li>N<br>追加换行符到pattern space, 并读入下一行输入追加到pattern space, 如果已经没有任何输入, 直接退出sed, 不再处理任何命令.</li>
<li>P<br>大写p, 打印pattern space第一行</li>
<li>z<br>清空pattern space</li>
</ul>
<h3>专家命令</h3>
<ul>
<li>: LABEL<br>设定标签, 类似C语言中设定一个标签, 然后可以goto之</li>
<li>b [LABEL]<br>跳转到标签, 如果没有提供标签的话, 直接进入下一轮循环</li>
<li>t [LABEL]<br>这轮循环中, 如果s命令替换成功过, 则跳转到标签. 如果没有提供标签的话, 直接进入下一轮循环</li>
<li>T LABEL<br>和t LABEL相反, s命令替换失败, 才跳转到标签</li>
</ul>
<h3>命令选项</h3>
<ul>
<li>-n, —quiet, —silent<br>禁止自动打印pattern space</li>
<li>-i[SUFFIX], —in-place[=SUFFIX]<br>原地编辑文件, 文本修改后会直接影响到输入文件</li>
<li>-r, —regexp-extended<br>启用扩展正则, 默认是基础正则</li>
<li>-s, —separate<br>把每个文件当作单独的输入流, 而不是一个输入流</li>
</ul>
<p>给我一个寄存器, 我可以干好多事</p>
<p>各位看完上面所说的sed命令后, 是不是觉得sed只能做一些替换、删除等操作， 为什么称为微语言呢, 我之所以把它归到微语言这一类是有原因的, 它具有下面几个语言的特征:</p>
<ol>
<li>有条件判断能力, sed的地址就是一种条件判断, 还有标签命令也是条件判断</li>
<li>有流程控制能力, 标签命令就可以做到</li>
<li>有变量, 虽然很少, 只有2个, 但是仍然可以干好多事了, 看下面的例子</li>
</ol>
<p>更多的例子参加sed info</p>
<ul>
<li>tac</li>
</ul>
<p>模拟tac<br><code>sed -n &#39;1!G; $p; h&#39;</code></p>
<p>为数字字串增加逗号分隔符号， 将1234567变为1,234,567</p>
<p><code>sed -r &#39;:a; s/(.*[0-9])([0-9]{3})/\1,\2/; ta&#39; &lt;&lt;&lt; 124523536543652</code></p>
<h2>12.2 awk (Alfred V. Aho, Peter J. Weinberger, Brian W. Kernighan.)</h2>
<p>awk是文本处理的利器, 前面那些命令能干的事它都能搞定.</p>
<h3>工作流程</h3>
<p>awk的工作方式有点类似sed, sed是地址+命令, awk则是pattern+action, pattern是要匹配的模式, action是要执行的命令, pattern可以由下面几种形式:</p>
<ul>
<li>BEGIN<br>awk程序开始处理输入时</li>
<li>END<br>awk程序结束处理输入时</li>
<li>BEGINFILE<br>awk程序开始处理每个文件时</li>
<li><p>ENDFILE<br>awk程序结束处理每个文件时</p>
</li>
<li><p>regular expression</p>
</li>
<li>relational expression</li>
</ul>
<p>关系表达式</p>
<pre><code><span class="bullet">* </span>pattern &amp;&amp; pattern
<span class="bullet">* </span>pattern || pattern
<span class="bullet">* </span>pattern ? pattern : pattern
<span class="bullet">* </span>(pattern)
<span class="bullet">* </span>! pattern
<span class="bullet">* </span>pattern1, pattern2</code></pre>
<p>action要以大括号括起来, 比如:</p>
<p><code>awk &#39;0{print} 1{print}&#39; .emacs</code></p>
<h3>内置变量</h3>
<ul>
<li>ARGC<br>awk输入参数的个数, 不包括awk自己</li>
<li>ARGV<br>命令行参数</li>
<li>ARGIND<br>当前处理的文件在ARGV中的位置, ARGV[ARGIND]表示当前正在处理的文件, 可以通过这个变量来对不同的输入文件做不同的处理</li>
<li>FNR (File Number Record)<br>当前文件的记录总数</li>
<li>NR (Number Record)<br>目前处理的记录总数</li>
<li>NF (Number of Field)<br>当前记录的字段数</li>
</ul>
<h3>网络编程</h3>
<p>awk能开发网络程序, 你相信吗?</p>
<pre><code><span class="formula">$ cat test.awk
<span class="special">#</span>!/usr/bin/awk -f

BEGIN <span class="special">{</span>
    str = "GET /index.html HTTP/1.1<span class="command">\r</span><span class="command">\nHost</span>: www.baidu.com<span class="command">\r</span><span class="command">\n</span><span class="command">\r</span><span class="command">\n</span>"
    print str |<span class="special">&amp;</span> "/inet/tcp/0/www.baidu.com/80"
    "/inet/tcp/0/www.baidu.com/80" |<span class="special">&amp;</span> getline
    print
<span class="special">}</span>

$</span> awk -f test.awk
HTTP/1.1 200 OK</code></pre>
<ul>
<li><p>陷阱</p>
<ul>
<li><p>tolower/toupper</p>
<p>和tr一样, 这2个函数也是对字节进行处理</p>
</li>
<li><p>判断元素是否存在</p>
<p>你是否这样判断某元素是否存在于某数组:</p>
<p><code>if (a[e] != 2) { ... }</code></p>
<p>如果输入很大的话, 过会你就会发现你的awk占了很多内存, 原因就是a[e]的时候, 如果awk发现a中没有e, 就会把e插入到a中, 这样一来内存自然越来越大, 正确的判断方法是:</p>
<p><code>if (!(e in a)) { ... }</code></p>
<p>用过python的朋友可能会这样写:</p>
<p><code>if (e not in a) { ... }</code></p>
<p>很不幸, 没有这样的语法, 而且还不报错, 我猜awk把e not连接成一个字符串了…</p>
</li>
</ul>
</li>
</ul>
<h1>13 语言</h1>
<p>a2p<br>s2p<br>perl<br>python</p>
<h1>14 实例</h1>
<h2>14.1 我的正则会数学</h2>
<p>multi-sort</p>
<h1>15 参考文献</h1>
<ul>
<li>相关命令的info及<br><a href="http://www.gnu.org/software/coreutils/manual/coreutils.pdf" target="_blank">coreutils</a></li>
<li><a href="http://www.tsnc.edu.cn/default/tsnc_wgrj/doc/abs-3.9.1_cn/html/textproc.html" target="_blank">高级Bash脚本编程指南: 文本处理命令</a></li>
<li><a href="http://www.cosc.brocku.ca/~taa/papers/abou-assaleh_csci6306a.pdf" target="_blank">Survey of Global Regular Expression Print (GREP) Tools</a></li>
</ul>

      
    </div>
    <footer>
      
        
  
  <div class="categories">
    <a href="/categories/linux/">linux</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/shell/">shell</a>, <a href="/tags/linux/">linux</a>
  </div>

        
  <div class="addthis addthis_toolbox addthis_default_style">
    
      <a class="addthis_button_facebook_like" fb:like:layout="button_count"></a>
    
    
      <a class="addthis_button_tweet"></a>
    
    
      <a class="addthis_button_google_plusone" g:plusone:size="medium"></a>
    
    
      <a class="addthis_button_pinterest_pinit" pi:pinit:layout="horizontal"></a>
    
    <a class="addthis_counter addthis_pill_style"></a>
  </div>
  <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js"></script>

      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>

</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:whatot.github.io">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/algorithm/">algorithm</a><small>1</small></li>
  
    <li><a href="/categories/basis/">basis</a><small>1</small></li>
  
    <li><a href="/categories/c/">c</a><small>3</small></li>
  
    <li><a href="/categories/database/">database</a><small>6</small></li>
  
    <li><a href="/categories/fun/">fun</a><small>1</small></li>
  
    <li><a href="/categories/git/">git</a><small>1</small></li>
  
    <li><a href="/categories/kernel/">kernel</a><small>2</small></li>
  
    <li><a href="/categories/linux/">linux</a><small>6</small></li>
  
    <li><a href="/categories/linux_program/">linux_program</a><small>3</small></li>
  
    <li><a href="/categories/program/">program</a><small>1</small></li>
  
    <li><a href="/categories/python/">python</a><small>1</small></li>
  
    <li><a href="/categories/thought/">thought</a><small>2</small></li>
  
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/CPU/">CPU</a><small>1</small></li>
  
    <li><a href="/tags/Makefile/">Makefile</a><small>1</small></li>
  
    <li><a href="/tags/algorithm/">algorithm</a><small>1</small></li>
  
    <li><a href="/tags/bash/">bash</a><small>1</small></li>
  
    <li><a href="/tags/c/">c</a><small>3</small></li>
  
    <li><a href="/tags/cache/">cache</a><small>1</small></li>
  
    <li><a href="/tags/career/">career</a><small>1</small></li>
  
    <li><a href="/tags/database/">database</a><small>6</small></li>
  
    <li><a href="/tags/fun/">fun</a><small>1</small></li>
  
    <li><a href="/tags/git/">git</a><small>1</small></li>
  
    <li><a href="/tags/kernel/">kernel</a><small>3</small></li>
  
    <li><a href="/tags/language/">language</a><small>4</small></li>
  
    <li><a href="/tags/linux/">linux</a><small>7</small></li>
  
    <li><a href="/tags/make/">make</a><small>1</small></li>
  
    <li><a href="/tags/math/">math</a><small>1</small></li>
  
    <li><a href="/tags/perf/">perf</a><small>1</small></li>
  
    <li><a href="/tags/program/">program</a><small>7</small></li>
  
    <li><a href="/tags/python/">python</a><small>1</small></li>
  
    <li><a href="/tags/regex/">regex</a><small>1</small></li>
  
    <li><a href="/tags/shell/">shell</a><small>6</small></li>
  
    <li><a href="/tags/thought/">thought</a><small>2</small></li>
  
    <li><a href="/tags/vim/">vim</a><small>1</small></li>
  
  </ul>
</div>


  
<div class="widget tagcloud">
  <h3 class="title">标签云</h3>
  <div class="entry">
    <a href="/tags/CPU/" style="font-size: 10.00px;">CPU</a><a href="/tags/Makefile/" style="font-size: 10.45px;">Makefile</a><a href="/tags/algorithm/" style="font-size: 10.91px;">algorithm</a><a href="/tags/bash/" style="font-size: 11.36px;">bash</a><a href="/tags/c/" style="font-size: 11.82px;">c</a><a href="/tags/cache/" style="font-size: 12.27px;">cache</a><a href="/tags/career/" style="font-size: 12.73px;">career</a><a href="/tags/database/" style="font-size: 13.18px;">database</a><a href="/tags/fun/" style="font-size: 13.64px;">fun</a><a href="/tags/git/" style="font-size: 14.09px;">git</a><a href="/tags/kernel/" style="font-size: 14.55px;">kernel</a><a href="/tags/language/" style="font-size: 15.00px;">language</a><a href="/tags/linux/" style="font-size: 15.45px;">linux</a><a href="/tags/make/" style="font-size: 15.91px;">make</a><a href="/tags/math/" style="font-size: 16.36px;">math</a><a href="/tags/perf/" style="font-size: 16.82px;">perf</a><a href="/tags/program/" style="font-size: 17.27px;">program</a><a href="/tags/python/" style="font-size: 17.73px;">python</a><a href="/tags/regex/" style="font-size: 18.18px;">regex</a><a href="/tags/shell/" style="font-size: 18.64px;">shell</a><a href="/tags/thought/" style="font-size: 19.09px;">thought</a><a href="/tags/vim/" style="font-size: 19.55px;">vim</a>
  </div>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2013 whatot
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>